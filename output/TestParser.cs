//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\aaron\\projects\\ttcn3\\Test.g 2012-10-23 23:10:46

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class TestParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "DIGIT", "INT", "LPAREN", "PLUS", "RPAREN", "SEMI", "STAR", "WS"
	};
	public const int EOF=-1;
	public const int DIGIT=4;
	public const int INT=5;
	public const int LPAREN=6;
	public const int PLUS=7;
	public const int RPAREN=8;
	public const int SEMI=9;
	public const int STAR=10;
	public const int WS=11;

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public TestParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TestParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}
	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return TestParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\aaron\\projects\\ttcn3\\Test.g"; } }


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_expr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_expr() {}

	// $ANTLR start "expr"
	// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:7:1: expr : mexpr ( PLUS ^ mexpr )* SEMI !;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 1);
		TraceIn("expr", 1);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken PLUS2 = default(IToken);
	    IToken SEMI4 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> mexpr1 = default(AstParserRuleReturnScope<object, IToken>);
	    AstParserRuleReturnScope<object, IToken> mexpr3 = default(AstParserRuleReturnScope<object, IToken>);

	    object PLUS2_tree = default(object);
	    object SEMI4_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(7, 0);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:7:6: ( mexpr ( PLUS ^ mexpr )* SEMI !)
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:7:8: mexpr ( PLUS ^ mexpr )* SEMI !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(7, 8);
			PushFollow(Follow._mexpr_in_expr29);
			mexpr1=mexpr();
			PopFollow();

			adaptor.AddChild(root_0, mexpr1.Tree);
			DebugLocation(7, 14);
			// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:7:14: ( PLUS ^ mexpr )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, decisionCanBacktrack[1]);
				int LA1_0 = input.LA(1);

				if ((LA1_0==PLUS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:7:15: PLUS ^ mexpr
					{
					DebugLocation(7, 19);
					PLUS2=(IToken)Match(input,PLUS,Follow._PLUS_in_expr32); 
					PLUS2_tree = (object)adaptor.Create(PLUS2);
					root_0 = (object)adaptor.BecomeRoot(PLUS2_tree, root_0);

					DebugLocation(7, 21);
					PushFollow(Follow._mexpr_in_expr35);
					mexpr3=mexpr();
					PopFollow();

					adaptor.AddChild(root_0, mexpr3.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(7, 33);
			SEMI4=(IToken)Match(input,SEMI,Follow._SEMI_in_expr39); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 1);
			LeaveRule("expr", 1);
			LeaveRule_expr();
	    }
	 	DebugLocation(8, 0);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_mexpr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_mexpr() {}

	// $ANTLR start "mexpr"
	// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:9:1: mexpr : atom ( STAR ^ atom )* ;
	[GrammarRule("mexpr")]
	private AstParserRuleReturnScope<object, IToken> mexpr()
	{
		EnterRule_mexpr();
		EnterRule("mexpr", 2);
		TraceIn("mexpr", 2);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken STAR6 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> atom5 = default(AstParserRuleReturnScope<object, IToken>);
	    AstParserRuleReturnScope<object, IToken> atom7 = default(AstParserRuleReturnScope<object, IToken>);

	    object STAR6_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "mexpr");
		DebugLocation(9, 0);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:10:3: ( atom ( STAR ^ atom )* )
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:10:3: atom ( STAR ^ atom )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(10, 3);
			PushFollow(Follow._atom_in_mexpr51);
			atom5=atom();
			PopFollow();

			adaptor.AddChild(root_0, atom5.Tree);
			DebugLocation(10, 8);
			// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:10:8: ( STAR ^ atom )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, decisionCanBacktrack[2]);
				int LA2_0 = input.LA(1);

				if ((LA2_0==STAR))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:10:9: STAR ^ atom
					{
					DebugLocation(10, 13);
					STAR6=(IToken)Match(input,STAR,Follow._STAR_in_mexpr54); 
					STAR6_tree = (object)adaptor.Create(STAR6);
					root_0 = (object)adaptor.BecomeRoot(STAR6_tree, root_0);

					DebugLocation(10, 15);
					PushFollow(Follow._atom_in_mexpr57);
					atom7=atom();
					PopFollow();

					adaptor.AddChild(root_0, atom7.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mexpr", 2);
			LeaveRule("mexpr", 2);
			LeaveRule_mexpr();
	    }
	 	DebugLocation(11, 0);
		} finally { DebugExitRule(GrammarFileName, "mexpr"); }
		return retval;

	}
	// $ANTLR end "mexpr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_atom() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_atom() {}

	// $ANTLR start "atom"
	// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:12:1: atom : INT ;
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 3);
		TraceIn("atom", 3);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken INT8 = default(IToken);

	    object INT8_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(12, 0);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:12:5: ( INT )
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:12:7: INT
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(12, 7);
			INT8=(IToken)Match(input,INT,Follow._INT_in_atom68); 
			INT8_tree = (object)adaptor.Create(INT8);
			adaptor.AddChild(root_0, INT8_tree);


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 3);
			LeaveRule("atom", 3);
			LeaveRule_atom();
	    }
	 	DebugLocation(13, 0);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _mexpr_in_expr29 = new BitSet(new ulong[]{0x280UL});
		public static readonly BitSet _PLUS_in_expr32 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _mexpr_in_expr35 = new BitSet(new ulong[]{0x280UL});
		public static readonly BitSet _SEMI_in_expr39 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_mexpr51 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _STAR_in_mexpr54 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _atom_in_mexpr57 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _INT_in_atom68 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
