//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\aaron\\projects\\ttcn3\\Test.g 2012-10-23 23:10:46

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class TestLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int DIGIT=4;
	public const int INT=5;
	public const int LPAREN=6;
	public const int PLUS=7;
	public const int RPAREN=8;
	public const int SEMI=9;
	public const int STAR=10;
	public const int WS=11;

    // delegates
    // delegators

	public TestLexer()
	{
		OnCreated();
	}

	public TestLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public TestLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "C:\\Users\\aaron\\projects\\ttcn3\\Test.g"; } }

	private static readonly bool[] decisionCanBacktrack = new bool[0];

	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_WS() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_WS() {}

    // $ANTLR start "WS"
    [GrammarRule("WS")]
    private void mWS()
    {
    	EnterRule_WS();
    	EnterRule("WS", 1);
    	TraceIn("WS", 1);
    		try
    		{
    		int _type = WS;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:15:4: ( ( ' ' | '\\t' | '\\n' | '\\r' ) )
    		DebugEnterAlt(1);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:15:6: ( ' ' | '\\t' | '\\n' | '\\r' )
    		{
    		DebugLocation(15, 6);
    		if ((input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ')
    		{
    			input.Consume();
    		}
    		else
    		{
    			MismatchedSetException mse = new MismatchedSetException(null,input);
    			DebugRecognitionException(mse);
    			Recover(mse);
    			throw mse;
    		}

    		DebugLocation(19, 1);
    		 _channel = HIDDEN; 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("WS", 1);
    		LeaveRule("WS", 1);
    		LeaveRule_WS();
        }
    }
    // $ANTLR end "WS"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_LPAREN() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_LPAREN() {}

    // $ANTLR start "LPAREN"
    [GrammarRule("LPAREN")]
    private void mLPAREN()
    {
    	EnterRule_LPAREN();
    	EnterRule("LPAREN", 2);
    	TraceIn("LPAREN", 2);
    		try
    		{
    		int _type = LPAREN;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:21:7: ( '(' )
    		DebugEnterAlt(1);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:21:9: '('
    		{
    		DebugLocation(21, 9);
    		Match('('); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("LPAREN", 2);
    		LeaveRule("LPAREN", 2);
    		LeaveRule_LPAREN();
        }
    }
    // $ANTLR end "LPAREN"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_RPAREN() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_RPAREN() {}

    // $ANTLR start "RPAREN"
    [GrammarRule("RPAREN")]
    private void mRPAREN()
    {
    	EnterRule_RPAREN();
    	EnterRule("RPAREN", 3);
    	TraceIn("RPAREN", 3);
    		try
    		{
    		int _type = RPAREN;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:23:7: ( ')' )
    		DebugEnterAlt(1);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:23:9: ')'
    		{
    		DebugLocation(23, 9);
    		Match(')'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("RPAREN", 3);
    		LeaveRule("RPAREN", 3);
    		LeaveRule_RPAREN();
        }
    }
    // $ANTLR end "RPAREN"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_STAR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_STAR() {}

    // $ANTLR start "STAR"
    [GrammarRule("STAR")]
    private void mSTAR()
    {
    	EnterRule_STAR();
    	EnterRule("STAR", 4);
    	TraceIn("STAR", 4);
    		try
    		{
    		int _type = STAR;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:25:5: ( '*' )
    		DebugEnterAlt(1);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:25:7: '*'
    		{
    		DebugLocation(25, 7);
    		Match('*'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("STAR", 4);
    		LeaveRule("STAR", 4);
    		LeaveRule_STAR();
        }
    }
    // $ANTLR end "STAR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_PLUS() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_PLUS() {}

    // $ANTLR start "PLUS"
    [GrammarRule("PLUS")]
    private void mPLUS()
    {
    	EnterRule_PLUS();
    	EnterRule("PLUS", 5);
    	TraceIn("PLUS", 5);
    		try
    		{
    		int _type = PLUS;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:27:5: ( '+' )
    		DebugEnterAlt(1);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:27:7: '+'
    		{
    		DebugLocation(27, 7);
    		Match('+'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("PLUS", 5);
    		LeaveRule("PLUS", 5);
    		LeaveRule_PLUS();
        }
    }
    // $ANTLR end "PLUS"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_SEMI() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_SEMI() {}

    // $ANTLR start "SEMI"
    [GrammarRule("SEMI")]
    private void mSEMI()
    {
    	EnterRule_SEMI();
    	EnterRule("SEMI", 6);
    	TraceIn("SEMI", 6);
    		try
    		{
    		int _type = SEMI;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:29:5: ( ';' )
    		DebugEnterAlt(1);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:29:7: ';'
    		{
    		DebugLocation(29, 7);
    		Match(';'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("SEMI", 6);
    		LeaveRule("SEMI", 6);
    		LeaveRule_SEMI();
        }
    }
    // $ANTLR end "SEMI"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_DIGIT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_DIGIT() {}

    // $ANTLR start "DIGIT"
    [GrammarRule("DIGIT")]
    protected void mDIGIT()
    {
    	EnterRule_DIGIT();
    	EnterRule("DIGIT", 7);
    	TraceIn("DIGIT", 7);
    		try
    		{
    		int _type = DIGIT;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:34:3: ( '0' .. '9' )
    		DebugEnterAlt(1);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:
    		{
    		DebugLocation(34, 3);
    		if ((input.LA(1)>='0' && input.LA(1)<='9'))
    		{
    			input.Consume();
    		}
    		else
    		{
    			MismatchedSetException mse = new MismatchedSetException(null,input);
    			DebugRecognitionException(mse);
    			Recover(mse);
    			throw mse;
    		}


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("DIGIT", 7);
    		LeaveRule("DIGIT", 7);
    		LeaveRule_DIGIT();
        }
    }
    // $ANTLR end "DIGIT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_INT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_INT() {}

    // $ANTLR start "INT"
    [GrammarRule("INT")]
    private void mINT()
    {
    	EnterRule_INT();
    	EnterRule("INT", 8);
    	TraceIn("INT", 8);
    		try
    		{
    		int _type = INT;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:35:5: ( ( DIGIT )+ )
    		DebugEnterAlt(1);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:35:7: ( DIGIT )+
    		{
    		DebugLocation(35, 7);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:35:7: ( DIGIT )+
    		int cnt1=0;
    		try { DebugEnterSubRule(1);
    		while (true)
    		{
    			int alt1=2;
    			try { DebugEnterDecision(1, decisionCanBacktrack[1]);
    			int LA1_0 = input.LA(1);

    			if (((LA1_0>='0' && LA1_0<='9')))
    			{
    				alt1 = 1;
    			}


    			} finally { DebugExitDecision(1); }
    			switch (alt1)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:
    				{
    				DebugLocation(35, 7);
    				input.Consume();


    				}
    				break;

    			default:
    				if (cnt1 >= 1)
    					goto loop1;

    				EarlyExitException eee1 = new EarlyExitException( 1, input );
    				DebugRecognitionException(eee1);
    				throw eee1;
    			}
    			cnt1++;
    		}
    		loop1:
    			;

    		} finally { DebugExitSubRule(1); }


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("INT", 8);
    		LeaveRule("INT", 8);
    		LeaveRule_INT();
        }
    }
    // $ANTLR end "INT"

    public override void mTokens()
    {
    	// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:1:8: ( WS | LPAREN | RPAREN | STAR | PLUS | SEMI | DIGIT | INT )
    	int alt2=8;
    	try { DebugEnterDecision(2, decisionCanBacktrack[2]);
    	switch (input.LA(1))
    	{
    	case '\t':
    	case '\n':
    	case '\r':
    	case ' ':
    		{
    		alt2 = 1;
    		}
    		break;
    	case '(':
    		{
    		alt2 = 2;
    		}
    		break;
    	case ')':
    		{
    		alt2 = 3;
    		}
    		break;
    	case '*':
    		{
    		alt2 = 4;
    		}
    		break;
    	case '+':
    		{
    		alt2 = 5;
    		}
    		break;
    	case ';':
    		{
    		alt2 = 6;
    		}
    		break;
    	case '0':
    	case '1':
    	case '2':
    	case '3':
    	case '4':
    	case '5':
    	case '6':
    	case '7':
    	case '8':
    	case '9':
    		{
    		int LA2_7 = input.LA(2);

    		if (((LA2_7>='0' && LA2_7<='9')))
    		{
    			alt2 = 8;
    		}
    		else
    		{
    			alt2 = 7;
    		}
    		}
    		break;
    	default:
    		{
    			NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    	}

    	} finally { DebugExitDecision(2); }
    	switch (alt2)
    	{
    	case 1:
    		DebugEnterAlt(1);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:1:10: WS
    		{
    		DebugLocation(1, 10);
    		mWS(); 

    		}
    		break;
    	case 2:
    		DebugEnterAlt(2);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:1:13: LPAREN
    		{
    		DebugLocation(1, 13);
    		mLPAREN(); 

    		}
    		break;
    	case 3:
    		DebugEnterAlt(3);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:1:20: RPAREN
    		{
    		DebugLocation(1, 20);
    		mRPAREN(); 

    		}
    		break;
    	case 4:
    		DebugEnterAlt(4);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:1:27: STAR
    		{
    		DebugLocation(1, 27);
    		mSTAR(); 

    		}
    		break;
    	case 5:
    		DebugEnterAlt(5);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:1:32: PLUS
    		{
    		DebugLocation(1, 32);
    		mPLUS(); 

    		}
    		break;
    	case 6:
    		DebugEnterAlt(6);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:1:37: SEMI
    		{
    		DebugLocation(1, 37);
    		mSEMI(); 

    		}
    		break;
    	case 7:
    		DebugEnterAlt(7);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:1:42: DIGIT
    		{
    		DebugLocation(1, 42);
    		mDIGIT(); 

    		}
    		break;
    	case 8:
    		DebugEnterAlt(8);
    		// C:\\Users\\aaron\\projects\\ttcn3\\Test.g:1:48: INT
    		{
    		DebugLocation(1, 48);
    		mINT(); 

    		}
    		break;

    	}

    }


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

 
	#endregion

}
