//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g 2012-10-24 22:06:47

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class TTCN3Parser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BITSTRING", "BOOLEAN", "CHAR", "CHARSTRING", "COMMENT", "ESC_QUOTE", "EXPONENT", "FLOAT", "HEX_DIGIT", "ID", "INT", "INTEGER", "LBRACKET", "OCTAL_ESC", "OCTETSTRING", "OPTIONAL", "RBRACKET", "RECORD", "STRING", "TYPE", "UNICODE_ESC", "WS", "','"
	};
	public const int EOF=-1;
	public const int T__26=26;
	public const int BITSTRING=4;
	public const int BOOLEAN=5;
	public const int CHAR=6;
	public const int CHARSTRING=7;
	public const int COMMENT=8;
	public const int ESC_QUOTE=9;
	public const int EXPONENT=10;
	public const int FLOAT=11;
	public const int HEX_DIGIT=12;
	public const int ID=13;
	public const int INT=14;
	public const int INTEGER=15;
	public const int LBRACKET=16;
	public const int OCTAL_ESC=17;
	public const int OCTETSTRING=18;
	public const int OPTIONAL=19;
	public const int RBRACKET=20;
	public const int RECORD=21;
	public const int STRING=22;
	public const int TYPE=23;
	public const int UNICODE_ESC=24;
	public const int WS=25;

	public TTCN3Parser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TTCN3Parser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return TTCN3Parser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g"; } }


	    public static void Main(string[] args) {
	        var fileStream = new ANTLRFileStream(args[0]);
	        var lexer = new TTCN3Lexer(fileStream);
	        var parser = new TTCN3Parser(new CommonTokenStream(lexer));
	        
	        /*
	        try {
	            while (fileStream.LA(1) != CharStreamConstants.EndOfFile)
	            {
	              var token = lexer.NextToken();
	              Console.WriteLine("token: {0}", token);
	            }
	        } catch (Exception e)  {
	            Console.Error.WriteLine(e.StackTrace);
	        }
	        */
	 
	        try {
	            var result = parser.typeDef();
	            Console.WriteLine("result {0}", result.Tree);
	        } catch (Exception e)  {
	            Console.Error.WriteLine(e.StackTrace);
	        }
	    }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_typeDef();
	partial void LeaveRule_typeDef();

	// $ANTLR start "typeDef"
	// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:40:1: typeDef : TYPE structuredTypeDef ;
	[GrammarRule("typeDef")]
	private AstParserRuleReturnScope<object, IToken> typeDef()
	{
		EnterRule_typeDef();
		EnterRule("typeDef", 1);
		TraceIn("typeDef", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPE1 = default(IToken);
		AstParserRuleReturnScope<object, IToken> structuredTypeDef2 = default(AstParserRuleReturnScope<object, IToken>);

		object TYPE1_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "typeDef");
		DebugLocation(40, 1);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:40:9: ( TYPE structuredTypeDef )
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:40:11: TYPE structuredTypeDef
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(40, 11);
			TYPE1=(IToken)Match(input,TYPE,Follow._TYPE_in_typeDef41); 
			TYPE1_tree = (object)adaptor.Create(TYPE1);
			adaptor.AddChild(root_0, TYPE1_tree);
			DebugLocation(40, 16);
			PushFollow(Follow._structuredTypeDef_in_typeDef43);
			structuredTypeDef2=structuredTypeDef();
			PopFollow();

			adaptor.AddChild(root_0, structuredTypeDef2.Tree);
			DebugLocation(40, 34);
			Console.WriteLine("Found typeDef");

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeDef", 1);
			LeaveRule("typeDef", 1);
			LeaveRule_typeDef();
		}
		DebugLocation(41, 1);
		} finally { DebugExitRule(GrammarFileName, "typeDef"); }
		return retval;

	}
	// $ANTLR end "typeDef"

	partial void EnterRule_structuredTypeDef();
	partial void LeaveRule_structuredTypeDef();

	// $ANTLR start "structuredTypeDef"
	// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:43:1: structuredTypeDef : recordDef ;
	[GrammarRule("structuredTypeDef")]
	private AstParserRuleReturnScope<object, IToken> structuredTypeDef()
	{
		EnterRule_structuredTypeDef();
		EnterRule("structuredTypeDef", 2);
		TraceIn("structuredTypeDef", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> recordDef3 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "structuredTypeDef");
		DebugLocation(43, 1);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:44:2: ( recordDef )
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:44:4: recordDef
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(44, 4);
			PushFollow(Follow._recordDef_in_structuredTypeDef56);
			recordDef3=recordDef();
			PopFollow();

			adaptor.AddChild(root_0, recordDef3.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("structuredTypeDef", 2);
			LeaveRule("structuredTypeDef", 2);
			LeaveRule_structuredTypeDef();
		}
		DebugLocation(45, 1);
		} finally { DebugExitRule(GrammarFileName, "structuredTypeDef"); }
		return retval;

	}
	// $ANTLR end "structuredTypeDef"

	partial void EnterRule_recordDef();
	partial void LeaveRule_recordDef();

	// $ANTLR start "recordDef"
	// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:47:1: recordDef : RECORD structDefBody ;
	[GrammarRule("recordDef")]
	private AstParserRuleReturnScope<object, IToken> recordDef()
	{
		EnterRule_recordDef();
		EnterRule("recordDef", 3);
		TraceIn("recordDef", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken RECORD4 = default(IToken);
		AstParserRuleReturnScope<object, IToken> structDefBody5 = default(AstParserRuleReturnScope<object, IToken>);

		object RECORD4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "recordDef");
		DebugLocation(47, 1);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:48:2: ( RECORD structDefBody )
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:48:4: RECORD structDefBody
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(48, 4);
			RECORD4=(IToken)Match(input,RECORD,Follow._RECORD_in_recordDef68); 
			RECORD4_tree = (object)adaptor.Create(RECORD4);
			adaptor.AddChild(root_0, RECORD4_tree);
			DebugLocation(48, 11);
			PushFollow(Follow._structDefBody_in_recordDef70);
			structDefBody5=structDefBody();
			PopFollow();

			adaptor.AddChild(root_0, structDefBody5.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("recordDef", 3);
			LeaveRule("recordDef", 3);
			LeaveRule_recordDef();
		}
		DebugLocation(49, 1);
		} finally { DebugExitRule(GrammarFileName, "recordDef"); }
		return retval;

	}
	// $ANTLR end "recordDef"

	partial void EnterRule_structDefBody();
	partial void LeaveRule_structDefBody();

	// $ANTLR start "structDefBody"
	// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:51:1: structDefBody : ID LBRACKET ( structFieldDef ( ',' structFieldDef )* )? RBRACKET ;
	[GrammarRule("structDefBody")]
	private AstParserRuleReturnScope<object, IToken> structDefBody()
	{
		EnterRule_structDefBody();
		EnterRule("structDefBody", 4);
		TraceIn("structDefBody", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID6 = default(IToken);
		IToken LBRACKET7 = default(IToken);
		IToken char_literal9 = default(IToken);
		IToken RBRACKET11 = default(IToken);
		AstParserRuleReturnScope<object, IToken> structFieldDef8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> structFieldDef10 = default(AstParserRuleReturnScope<object, IToken>);

		object ID6_tree = default(object);
		object LBRACKET7_tree = default(object);
		object char_literal9_tree = default(object);
		object RBRACKET11_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "structDefBody");
		DebugLocation(51, 1);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:52:2: ( ID LBRACKET ( structFieldDef ( ',' structFieldDef )* )? RBRACKET )
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:52:4: ID LBRACKET ( structFieldDef ( ',' structFieldDef )* )? RBRACKET
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(52, 4);
			ID6=(IToken)Match(input,ID,Follow._ID_in_structDefBody81); 
			ID6_tree = (object)adaptor.Create(ID6);
			adaptor.AddChild(root_0, ID6_tree);
			DebugLocation(52, 7);
			LBRACKET7=(IToken)Match(input,LBRACKET,Follow._LBRACKET_in_structDefBody83); 
			LBRACKET7_tree = (object)adaptor.Create(LBRACKET7);
			adaptor.AddChild(root_0, LBRACKET7_tree);
			DebugLocation(52, 16);
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:52:16: ( structFieldDef ( ',' structFieldDef )* )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if (((LA2_0>=BITSTRING && LA2_0<=CHARSTRING)||LA2_0==INTEGER||LA2_0==OCTETSTRING))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:52:17: structFieldDef ( ',' structFieldDef )*
				{
				DebugLocation(52, 17);
				PushFollow(Follow._structFieldDef_in_structDefBody86);
				structFieldDef8=structFieldDef();
				PopFollow();

				adaptor.AddChild(root_0, structFieldDef8.Tree);
				DebugLocation(52, 32);
				// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:52:32: ( ',' structFieldDef )*
				try { DebugEnterSubRule(1);
				while (true)
				{
					int alt1=2;
					try { DebugEnterDecision(1, false);
					int LA1_0 = input.LA(1);

					if ((LA1_0==26))
					{
						alt1 = 1;
					}


					} finally { DebugExitDecision(1); }
					switch ( alt1 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:52:33: ',' structFieldDef
						{
						DebugLocation(52, 33);
						char_literal9=(IToken)Match(input,26,Follow._26_in_structDefBody89); 
						char_literal9_tree = (object)adaptor.Create(char_literal9);
						adaptor.AddChild(root_0, char_literal9_tree);
						DebugLocation(52, 37);
						PushFollow(Follow._structFieldDef_in_structDefBody91);
						structFieldDef10=structFieldDef();
						PopFollow();

						adaptor.AddChild(root_0, structFieldDef10.Tree);

						}
						break;

					default:
						goto loop1;
					}
				}

				loop1:
					;

				} finally { DebugExitSubRule(1); }


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(52, 56);
			RBRACKET11=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_structDefBody97); 
			RBRACKET11_tree = (object)adaptor.Create(RBRACKET11);
			adaptor.AddChild(root_0, RBRACKET11_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("structDefBody", 4);
			LeaveRule("structDefBody", 4);
			LeaveRule_structDefBody();
		}
		DebugLocation(53, 1);
		} finally { DebugExitRule(GrammarFileName, "structDefBody"); }
		return retval;

	}
	// $ANTLR end "structDefBody"

	partial void EnterRule_structFieldDef();
	partial void LeaveRule_structFieldDef();

	// $ANTLR start "structFieldDef"
	// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:55:1: structFieldDef : type ID ( OPTIONAL )? ;
	[GrammarRule("structFieldDef")]
	private AstParserRuleReturnScope<object, IToken> structFieldDef()
	{
		EnterRule_structFieldDef();
		EnterRule("structFieldDef", 5);
		TraceIn("structFieldDef", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID13 = default(IToken);
		IToken OPTIONAL14 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type12 = default(AstParserRuleReturnScope<object, IToken>);

		object ID13_tree = default(object);
		object OPTIONAL14_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "structFieldDef");
		DebugLocation(55, 1);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:56:2: ( type ID ( OPTIONAL )? )
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:56:4: type ID ( OPTIONAL )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(56, 4);
			PushFollow(Follow._type_in_structFieldDef108);
			type12=type();
			PopFollow();

			adaptor.AddChild(root_0, type12.Tree);
			DebugLocation(56, 9);
			ID13=(IToken)Match(input,ID,Follow._ID_in_structFieldDef110); 
			ID13_tree = (object)adaptor.Create(ID13);
			adaptor.AddChild(root_0, ID13_tree);
			DebugLocation(56, 12);
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:56:12: ( OPTIONAL )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==OPTIONAL))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:56:12: OPTIONAL
				{
				DebugLocation(56, 12);
				OPTIONAL14=(IToken)Match(input,OPTIONAL,Follow._OPTIONAL_in_structFieldDef112); 
				OPTIONAL14_tree = (object)adaptor.Create(OPTIONAL14);
				adaptor.AddChild(root_0, OPTIONAL14_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("structFieldDef", 5);
			LeaveRule("structFieldDef", 5);
			LeaveRule_structFieldDef();
		}
		DebugLocation(57, 1);
		} finally { DebugExitRule(GrammarFileName, "structFieldDef"); }
		return retval;

	}
	// $ANTLR end "structFieldDef"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:59:1: type : predefinedType ;
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 6);
		TraceIn("type", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> predefinedType15 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(59, 1);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:59:7: ( predefinedType )
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:59:9: predefinedType
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(59, 9);
			PushFollow(Follow._predefinedType_in_type125);
			predefinedType15=predefinedType();
			PopFollow();

			adaptor.AddChild(root_0, predefinedType15.Tree);
			DebugLocation(59, 24);
			Console.WriteLine("Found typedef start");

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 6);
			LeaveRule("type", 6);
			LeaveRule_type();
		}
		DebugLocation(60, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_predefinedType();
	partial void LeaveRule_predefinedType();

	// $ANTLR start "predefinedType"
	// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:62:1: predefinedType : ( BITSTRING | BOOLEAN | CHARSTRING | CHAR | INTEGER | OCTETSTRING );
	[GrammarRule("predefinedType")]
	private AstParserRuleReturnScope<object, IToken> predefinedType()
	{
		EnterRule_predefinedType();
		EnterRule("predefinedType", 7);
		TraceIn("predefinedType", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set16 = default(IToken);

		object set16_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "predefinedType");
		DebugLocation(62, 1);
		try
		{
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:63:2: ( BITSTRING | BOOLEAN | CHARSTRING | CHAR | INTEGER | OCTETSTRING )
			DebugEnterAlt(1);
			// C:\\Users\\aaron\\projects\\ttcn3\\csharp\\TTCN3.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(63, 2);

			set16=(IToken)input.LT(1);
			if ((input.LA(1)>=BITSTRING && input.LA(1)<=CHARSTRING)||input.LA(1)==INTEGER||input.LA(1)==OCTETSTRING)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set16));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("predefinedType", 7);
			LeaveRule("predefinedType", 7);
			LeaveRule_predefinedType();
		}
		DebugLocation(64, 1);
		} finally { DebugExitRule(GrammarFileName, "predefinedType"); }
		return retval;

	}
	// $ANTLR end "predefinedType"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _TYPE_in_typeDef41 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _structuredTypeDef_in_typeDef43 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _recordDef_in_structuredTypeDef56 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RECORD_in_recordDef68 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _structDefBody_in_recordDef70 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_structDefBody81 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _LBRACKET_in_structDefBody83 = new BitSet(new ulong[]{0x1480F0UL});
		public static readonly BitSet _structFieldDef_in_structDefBody86 = new BitSet(new ulong[]{0x4100000UL});
		public static readonly BitSet _26_in_structDefBody89 = new BitSet(new ulong[]{0x480F0UL});
		public static readonly BitSet _structFieldDef_in_structDefBody91 = new BitSet(new ulong[]{0x4100000UL});
		public static readonly BitSet _RBRACKET_in_structDefBody97 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_structFieldDef108 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _ID_in_structFieldDef110 = new BitSet(new ulong[]{0x80002UL});
		public static readonly BitSet _OPTIONAL_in_structFieldDef112 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _predefinedType_in_type125 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
