/******************************************************************************/
// @copyright   Copyright Notification
//   No part may be reproduced except as authorized by written permission.
//   The copyright and the foregoing restriction extend to reproduction in all media.
//   Trademark 2011, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TTA, TTC).
//   All rights reserved.
// @version: 36.523-3v10.1.0
// $Date: 2012-08-19 14:09:05 +0200 (Sun, 19 Aug 2012) $
// $Rev: 7121 $
/******************************************************************************/

module RLC_AM_Testcases {

  import from EUTRA_RRC_ASN1_Definitions language "ASN.1:1997" all;
  import from CommonDefs all;
  import from EUTRA_ASP_DrbDefs all;
  import from EUTRA_ASP_TypeDefs all;
  import from EUTRA_AspCommon_Templates all;
  import from EUTRA_CellCfg_Templates all;
  import from EUTRA_CellInfo all;
  import from EUTRA_CommonDefs all;
  import from EUTRA_CommonProcedures all;
  import from EUTRA_Component all;
  import from EUTRA_ConfigurationSteps all;
  import from EUTRA_DRB_Templates all;
  import from EUTRA_LoopBack all;
  import from EUTRA_RRCSteps all;
  import from EUTRA_RRC_Templates all;
  import from EUTRA_SRB_Templates all;
  import from EUTRA_SecurityFunctions all;
  import from EUTRA_SecuritySteps all;
  import from EUTRA_Timing all;
  import from L2_CommonFunctions all;
  import from L2_CommonTemplates all;
  import from RLC_AM_Templates all;
  import from RLC_Common all;

group RLCAM_Functions {

function f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(EUTRA_CellId_Type p_CellId,
                                          template (value) TimingInfo_Type p_TimingInfo := cs_TimingInfo_Now) runs on EUTRA_PTC
{
  f_EUTRA_SS_CommonRadioBearerConfig_SingleDRB(p_CellId, cs_DRB1_ConfigAM_TM_Mode, p_TimingInfo);
}

function f_GetTxAM_PRBS (inout RLC_SS_State p_RLC_Rec)
{
  var integer v_TxDataSize := p_RLC_Rec.TxDataSize;
  var integer v_TxPRBS_Pos := p_RLC_Rec.TxPRBS_Pos;
  var octetstring v_RLC_Data;
  
  if (v_TxDataSize <= 0) {
    v_RLC_Data := ''O;
  } else {
    if (v_TxDataSize >= 0) {
      v_RLC_Data := f_GetN_OctetsFromPRBS( v_TxPRBS_Pos, v_TxDataSize);
      v_TxPRBS_Pos := v_TxPRBS_Pos + v_TxDataSize;
      if (v_TxPRBS_Pos >= tsc_MaxPRBS_Pos) {
        v_TxPRBS_Pos := v_TxPRBS_Pos - tsc_MaxPRBS_Pos;
      } else {}
    }
  }
  p_RLC_Rec.TxPRBS_Pos := v_TxPRBS_Pos;
  p_RLC_Rec.RLC_Data := v_RLC_Data;
} // f_GetTxAM_PRBS

function f_TxAMD_OnePDU (inout RLC_SS_State p_RLC_Rec,
                         template (value) TimingInfo_Type p_TimingInfo,
                         B1_Type p_Poll,
                         RLC_FramingInfo_Type p_FramingInfo,
                         RLC_DataField_Type p_RLC_Data)
  runs on EUTRA_PTC
{
  //  build PDU constraint, can be simplified !
  p_RLC_Rec.AMD_PDU := valueof (cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                  p_Poll,
                                                  p_FramingInfo,
                                                  {p_RLC_Data} ));
  //  send PDU
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   p_TimingInfo,
                                   p_RLC_Rec.AMD_PDU));
  p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
} // f_TxAMD_OnePDU

function f_TxAMD_PDU_List (inout RLC_SS_State p_RLC_Rec,
                           template (value) TimingInfo_Type p_TimingInfo,
                           B1_Type p_Poll,
                           RLC_FramingInfo_Type p_FramingInfo,
                           RLC_DataFieldList_Type p_RLC_Data,
                           boolean p_LI_Error := tsc_NoLI_Error)
  runs on EUTRA_PTC
{
  var integer v_LI1, v_LI2;
  
  select (lengthof (p_RLC_Data))
    {
      case (2)
        {
          v_LI1 := lengthof (p_RLC_Data[0]);
          if ( p_LI_Error ) { // LI error needs to be generated
            // 2 octets for PDCP header + 1 octet for LI error
            v_LI1 := v_LI1 + lengthof (p_RLC_Data[1]) + 1;
            // check that AM SN size is respected
            if ( v_LI1 > 1023) {
              FatalError(__FILE__, __LINE__, "LI error calculation incorrect");
            }
          }
          p_RLC_Rec.AMD_PDU := valueof (cs_AMD_PDU_LIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                        p_Poll,
                                                        p_FramingInfo,
                                                        cs_FlexPart_1LI(v_LI1),
                                                        p_RLC_Data));
        }
      case (3)
        {
          v_LI1 := lengthof (p_RLC_Data[0]);
          v_LI2 := lengthof (p_RLC_Data[1]);
          p_RLC_Rec.AMD_PDU := valueof (cs_AMD_PDU_LIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                        p_Poll,
                                                        p_FramingInfo,
                                                        cs_FlexPart_2LIs(v_LI1, v_LI2),
                                                        p_RLC_Data));
        }
      case else
             {
               FatalError(__FILE__, __LINE__, "Function used in a currently unforeseen way");
             }
    } // end select
  //  send PDU
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   p_TimingInfo,
                                   p_RLC_Rec.AMD_PDU));
  p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
} // f_TxAMD_PDU_List

function f_TxAMD_PDU_OneSeg (inout RLC_SS_State p_RLC_Rec,
                             template (value) TimingInfo_Type p_TimingInfo,
                             B1_Type p_Poll,
                             RLC_FramingInfo_Type p_FramingInfo,
                             B1_Type p_LSF,
                             integer p_SegOffset,
                             RLC_DataField_Type p_RLC_Data)
  runs on EUTRA_PTC
{
  p_RLC_Rec.AMD_PDU := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                     p_Poll,
                                                     p_FramingInfo,
                                                     p_LSF,
                                                     p_SegOffset,
                                                     {p_RLC_Data} ));
  //  send PDU
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   p_TimingInfo,
                                   p_RLC_Rec.AMD_PDU));
  // VTS is not updated by this function: must be administered by the user of this function
} // f_TxAMD_PDU_OneSeg

function f_TxAMD_SegList (inout RLC_SS_State p_RLC_Rec,
                          template (value) TimingInfo_Type p_TimingInfo,
                          B1_Type p_Poll,
                          RLC_FramingInfo_Type p_FramingInfo,
                          B1_Type p_LastSegmentFlag,
                          integer p_SegOffset,
                          RLC_DataFieldList_Type p_RLC_Data)
  runs on EUTRA_PTC
{
  var integer v_LI1, v_LI2;
  
  select (lengthof (p_RLC_Data)) {
    case (2) {
      v_LI1 := lengthof (p_RLC_Data[0]);
      p_RLC_Rec.AMD_PDU := valueof(cs_AMD_PDU_seg_LIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                       p_Poll,
                                                       p_FramingInfo,
                                                       p_LastSegmentFlag,
                                                       p_SegOffset,
                                                       cs_FlexPart_1LI(v_LI1),
                                                       p_RLC_Data));
    }
    case (3) {
      v_LI1 := lengthof (p_RLC_Data[0]);
      v_LI2 := lengthof (p_RLC_Data[1]);
      p_RLC_Rec.AMD_PDU := valueof(cs_AMD_PDU_seg_LIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                       p_Poll,
                                                       p_FramingInfo,
                                                       p_LastSegmentFlag,
                                                       p_SegOffset,
                                                       cs_FlexPart_2LIs(v_LI1, v_LI2),
                                                       p_RLC_Data));
    }
    case else {
      FatalError(__FILE__, __LINE__, "Function used in a currently unforeseen way");
    }
  } // end select
  //  send PDU
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   p_TimingInfo,
                                   p_RLC_Rec.AMD_PDU));
  // VTS is not updated by this function: must be administered by the user of this function
} // f_TxAMD_SegList

function f_TxAMD_SDU (inout RLC_SS_State p_RLC_Rec,
                      template (value) TimingInfo_Type p_TimingInfo,
                      B1_Type p_Poll,
                      integer p_SDU_Num)
  runs on EUTRA_PTC
{
  //  build PDU constraint, can be simplified !
  p_RLC_Rec.AMD_PDU := valueof(cs_AMD_PDUoneSDU(p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                p_Poll,
                                                {p_RLC_Rec.RLC_DataList[p_SDU_Num]} ));
  //  send PDU containing SDU
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   p_TimingInfo,
                                   p_RLC_Rec.AMD_PDU));
  p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
} // f_TxAMD_SDU

function f_RxAMD_SDU (inout RLC_SS_State p_RLC_Rec,
                      B1_Type p_Poll,
                      integer p_SDU_Num)
  runs on EUTRA_PTC
{
  var DRB_COMMON_IND v_ReceivedAsp;
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       p_Poll,
                                                       {p_RLC_Rec.RLC_DataList[p_SDU_Num]} ))) -> value v_ReceivedAsp;
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  p_RLC_Rec.TimeStampLastReceivedPDU := v_ReceivedAsp.Common.TimingInfo.SubFrame;
} // f_RxAMD_SDU

function f_RxAMD_PDU (inout RLC_SS_State p_RLC_Rec,
                      B1_Type p_Poll,
                      RLC_FramingInfo_Type p_FramingInfo,
                      template RLC_PDU_Header_FlexPart_Type p_Header_FlexPart,
                      RLC_DataFieldList_Type p_Data )
  runs on EUTRA_PTC
{
  var DRB_COMMON_IND v_ReceivedAsp;
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDU_LIs (p_RLC_Rec.AM_VRR,
                                                      p_Poll,
                                                      p_FramingInfo,
                                                      p_Header_FlexPart,
                                                      p_Data))) -> value v_ReceivedAsp;
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  p_RLC_Rec.TimeStampLastReceivedPDU := v_ReceivedAsp.Common.TimingInfo.SubFrame;
} // f_RxAMD_PDU

function f_RxSTATUS_PDU_ACK(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{
  DRB.receive(car_DRB1_RLCStatusInd(eutra_Cell1,
                                    cr_RLC_AM_StatusPDU_ACK_SN(p_RLC_Rec.AM_VTA)));
}  // f_RxSTATUS_PDU_ACK

function f_RxSTATUS_PDU_NACK(inout RLC_SS_State p_RLC_Rec,
                             template (value) RLC_Status_NACK_List_Type p_NACK_List,
                             template (present) RLC_Status_Padding_Type p_Padding)
  runs on EUTRA_PTC
{
  var DRB_COMMON_IND v_ReceivedAsp;
  DRB.receive(car_DRB1_RLCStatusInd(eutra_Cell1,
                                    cr_STATUS_PDU_Nack(p_RLC_Rec.AM_VTA,
                                                       p_NACK_List,
                                                       p_Padding))) -> value v_ReceivedAsp;
  p_RLC_Rec.AM_VTA := (p_RLC_Rec.AM_VTA + 1) mod 1024;
  p_RLC_Rec.TimeStampLastReceivedPDU := v_ReceivedAsp.Common.TimingInfo.SubFrame;  // @sic R5s110019 sic@
}  // f_RxSTATUS_PDU_NACK

function f_TxSTATUS_PDU(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{
  p_RLC_Rec.StatusPDU := valueof(cs_RLC_AM_StatusPDU_ACK_SN(p_RLC_Rec.AM_VRR));
  //  send STATUS PDU
  DRB.send (cas_DRB1_RLCStatusReq (eutra_Cell1,
                                   cs_TimingInfo_Now,
                                   p_RLC_Rec.StatusPDU));
}  // f_TxSTATUS_PDU

function f_TxSTATUS_PDU_NACK(inout RLC_SS_State p_RLC_Rec,
                             template (value) RLC_Status_NACK_List_Type p_NACK_List,
                             RLC_Status_Padding_Type p_Padding,
                             template (value) TimingInfo_Type p_TimingInfo := cs_TimingInfo_Now) runs on EUTRA_PTC
{
  p_RLC_Rec.StatusPDU := valueof(cs_STATUS_PDU_Nack(p_RLC_Rec.AM_VRR,             // Note: valueof cannot be avoided here
                                                    p_NACK_List,
                                                    p_Padding));
  //  send STATUS PDU
  DRB.send (cas_DRB1_RLCStatusReq (eutra_Cell1,
                                   p_TimingInfo,
                                   p_RLC_Rec.StatusPDU));
}  // f_TxSTATUS_PDU_NACK

function fl_EUTRA_GenericRbEst_WithRLC_AM_Params(EUTRA_CellId_Type p_CellId,
                                                 template (value) DRB_ToAddModList p_DRB_ToAddModList,
                                                 template (omit) PhysicalConfigDedicated p_PhysicalConfigDedicated := omit,
                                                 boolean p_PDCP_StatusReportRequired := true) runs on EUTRA_PTC
{
  f_EUTRA_GenericRbEst_DisableBSR_PHR(p_CellId,
                                      0,
                                      0,
                                      p_DRB_ToAddModList,
                                      omit,
                                      p_PhysicalConfigDedicated,
                                      omit,
                                      omit,
                                      p_PDCP_StatusReportRequired ); // @sic R5s110030 sic@
}  // fl_EUTRA_GenericRbEst_WithRLC_AM_Params

} // end of group RLCAM_Functions

group AM_Testcases {

function f_TC_7_2_3_1_EUTRA()
  runs on EUTRA_PTC
{
  var RLC_SS_State v_RLC_Rec;

  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode); // @sic R5s100020 sic@
  
  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 100;
  // updating the status prohibit timer to the value defined in prose in preamble
  v_RLC_Rec.t_StatusProhibit := 0.5;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3 with test case specific RLC parameters, with BSR and PHR disabled
  fl_EUTRA_GenericRbEst_WithRLC_AM_Params (eutra_Cell1,
                                           {cs_DRB_ToAddMod_RLC_AM (tsc_DRB1,
                                                                    cs_508_DRB_UL_AM_RLC,
                                                                    cds_RX_AM_RLC_StatProh(ms500))});
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(raiseInconc);
  fl_EUTRA_7_2_3_1_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // assigning the default grant again
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_1_EUTRA

function fl_EUTRA_7_2_3_1_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5s100047 sic@ @sic R5-105016 sic@
  var integer i;
  var RLC_DataField_Type v_RLC_Data1, v_RLC_Data2, v_RLC_Data3;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var SubFrameTiming_Type v_Timing;
  var DRB_COMMON_IND v_ReceivedAsp;

  // PDCP SDU size employed: 38 bytes
  var integer v_PDCP_SDU_size := 38;
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  
  // generate 5 RLC SDUs = PDCP PDUs
  for (i := 0; i < 5; i:= i + 1) {
    p_RLC_Rec.TxDataSize := v_PDCP_SDU_size;
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 1" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 2" siclog@
  // SS transmits an AMD PDU including two RLC SDUs of size 40 bytes each with poll bit set to '1'.
  //100 ms to wait for having an accurate reference to start
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 40);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 40);
  f_TxAMD_PDU_List( p_RLC_Rec,
                    cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                    tsc_P_Poll,
                    tsc_FI_FullSDU,
                    {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 3" siclog@
  // The SS waits 60 ms and then allocates an UL grant (UL grant allocation type 3) of size 776 bits (Note 1).
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_OneULGrantTransmission( eutra_Cell1,
                                  cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                  12, 4); // Imcs = 12 -> Itbs = 11
  
  //@siclog "Step 4" siclog@
  // Check: Does UE transmit a STATUS PDU with positive acknowledgement ?
  p_RLC_Rec.AM_VTA := 1;
  // receive STATUS PDU + DATA PDU in the same TTI, thus in a list
  DRB.receive (car_DRB1_RLCAmStatusAndDataInd( eutra_Cell1,
                                               ?,
                                               ?)) -> value v_ReceivedAsp;
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].Status,
             cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA )))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 4");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 4");
    }
  //@siclog "Step 5" siclog@
  // Check: Does UE transmit two RLC SDUs within an AMD PDU with FI field set to '00',
  // first E field in the fixed part set to '1', first E field in the extension part set to '0', first LI field set to 40 bytes?
  // concatenate both SDUs
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 40);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 40);
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[1].AMD,
             cr_AMD_PDU_LIs (p_RLC_Rec.AM_VRR,
                             tsc_P_Poll,
                             tsc_FI_FullSDU,
                             cr_FlexPart_1LI (40),
                             {v_RLC_Data1, v_RLC_Data2})))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 5");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 5");
    }
  p_RLC_Rec.AM_VRR := 1;
  //@siclog "Step 6" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU (p_RLC_Rec);
  //@siclog "Step 7" siclog@
  // After 500ms the SS transmits an AMD PDU including three RLC SDU of size 40 bytes with P field set to "1".
  // 500 ms to wait for having an accurate reference to start
  // @sic R5s100068 sic@ @sic R5-104148 sic@
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1, 500);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 40);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 0, 40);
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 0, 40);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                   tsc_P_Poll,
                   tsc_FI_FullSDU,
                   {v_RLC_Data1, v_RLC_Data2, v_RLC_Data3});
  //@siclog "Step 8" siclog@
  // The SS waits 60 ms and then allocates an UL grant (UL grant allocation type 3) of size 1096 bits (Note 2).
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_OneULGrantTransmission( eutra_Cell1,
                                  cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                  8, 8); // Imcs = 8 -> Itbs = 8
  //@siclog "Step 9" siclog@
  // Check: Does UE transmits a STATUS PDU with positive acknowledgement?
  p_RLC_Rec.AM_VTA := 2;
  // receive STATUS PDU + DATA PDU in the same TTI, thus in a list
  DRB.receive (car_DRB1_RLCAmStatusAndDataInd( eutra_Cell1,
                                               ?,
                                               ?)) -> value v_ReceivedAsp;
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].Status,
             cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA )))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 9");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 9");
    }
  //@siclog "Step 10" siclog@
  // Check: Does UE transmit three RLC SDUs within an AMD PDU with FI field set to "00", first E field in the fixed part set to '1',
  // first E field in the extension part set to '1', first LI field set to 40 bytes, second E field in the extension part set to '0',
  // second LI field set to 40 bytes and P field set to "1"?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 40);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 0, 40);
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 0, 40);
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[1].AMD,
             cr_AMD_PDU_LIs (p_RLC_Rec.AM_VRR,
                             tsc_P_Poll,
                             tsc_FI_FullSDU,
                             cr_FlexPart_2LIs (40, 40),
                             {v_RLC_Data1, v_RLC_Data2, v_RLC_Data3} )))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 10");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 10");
    }
  p_RLC_Rec.AM_VRR := 2;
  //@siclog "Step 11" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_1_TestBody

function f_TC_7_2_3_2_EUTRA()
  runs on EUTRA_PTC
{
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  // closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);

  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(raiseInconc);
  fl_EUTRA_7_2_3_2_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // assigning the default grant again
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_2_EUTRA

function fl_EUTRA_7_2_3_2_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{
  var integer i;
  var RLC_DataField_Type v_RLC_Data1, v_RLC_Data2, v_RLC_Data3;
  var template (value) DRB_DataPerSubframeList_DL_Type v_SubframeDataList;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var DRB_COMMON_IND v_ReceivedAsp;
  // timer value to be used as per configuration
  var integer v_DurationAB;
  var integer v_DurationBC;
  var SubFrameTiming_Type v_SubFrameTimingTa;
  var SubFrameTiming_Type v_SubFrameTimingTb;
  var SubFrameTiming_Type v_SubFrameTimingTc;
  var SubFrameTiming_Type v_Timing;
  
  // PDCP SDU size employed: 78, 118 bytes
  var integer v_PDCP_SDU_size[2]:= {78, 118};
  
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  
  // generate 5 RLC SDUs = PDCP PDUs
  for (i := 0; i < 2; i:= i + 1) {
    p_RLC_Rec.TxDataSize := v_PDCP_SDU_size[i];
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 1" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 2" siclog@
  // The SS transmits a RLC SDU of size 80 bytes segmented into two AMD PDUs.
  // The two AMD PDUs are transmitted in separate TTIs.
  // 1. construct the RLC DATA
  v_RLC_Data1 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 40);
  v_RLC_Data2 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 40, 40);
  // 2. build the list of PDUs
  v_SubframeDataList[0].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0); // @sic R5s090361 sic@ @sic R5s100002 sic@
  v_SubframeDataList[0].HarqProcess := {Automatic := true};
  v_SubframeDataList[0].PduSduList := { RlcPdu := {{AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                                                             tsc_P_NoPoll,
                                                                             tsc_FI_StartOfSDU,
                                                                             {v_RLC_Data1} )}}};
  p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  v_SubframeDataList[1].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1); // @sic R5s090361 sic@ @sic R5s100002 sic@
  v_SubframeDataList[1].HarqProcess := {Automatic := true};
  v_SubframeDataList[1].PduSduList := { RlcPdu := {{AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                                                             tsc_P_NoPoll,
                                                                             tsc_FI_EndOfSDU,
                                                                             {v_RLC_Data2} )}}};
  p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  // 3. send the list of PDUs
  // at least 100 ms to wait for having an accurate reference to start
  // subframe number 0 required to fit with the TDD subframe offsets
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1); // @sic R5s090361 sic@ @sic R5s100039 sic@
  DRB.send (cas_DRB1_RLCAmDataReq_List (eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList));
  
  //@siclog "Step 3" siclog@
  // 60 ms after step 2 the SS allocates 2 UL grants (UL grant allocation type 2) of size 392 bits. (Note 1).
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, 60 );
  f_EUTRA_PeriodicCyclicULGrantTransmission( eutra_Cell1,
                                             cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                             8,
                                             3,
                                             5, // @sic R5s110394 sic@
                                             2);
  
  //@siclog "Step 4" siclog@
  // Check: Does the UE return a RLC SDU with equal content as sent in downlink
  // in step 2 segmented into two AMD PDUs and received in different TTIs?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 44);
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDU_NoLIs (p_RLC_Rec.AM_VRR,
                                                        tsc_P_NoPoll,
                                                        tsc_FI_StartOfSDU,
                                                        {v_RLC_Data1} ))) -> value v_ReceivedAsp;
  v_SubFrameTimingTa := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  // Wait for AMD PDU#2.
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 44, 36);
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDU_NoLIs (p_RLC_Rec.AM_VRR,
                                                        tsc_P_Poll,
                                                        tsc_FI_EndOfSDU,
                                                        {v_RLC_Data2} ))) -> value v_ReceivedAsp;
  v_SubFrameTimingTb := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  v_DurationAB := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTa, v_SubFrameTimingTb);
  if ( v_DurationAB > 0 )
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 4");
    }
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;  // @sic CR R5-090156 sic@
  //@siclog "Step 5" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 6" siclog@
  // The SS sends a RLC SDU of size 120 bytes octets segmented into three AMD PDUs.
  // 1. construct the RLC DATA
  v_RLC_Data1 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 40);
  v_RLC_Data2 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 40, 40);
  v_RLC_Data3 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 80, 40);
  // 2. build the list of PDUs
  v_SubframeDataList[0].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);  // @sic R5s090361 sic@ @sic R5s100002 sic@
  v_SubframeDataList[0].HarqProcess := {Automatic := true};
  v_SubframeDataList[0].PduSduList := { RlcPdu := {{AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                                                             tsc_P_NoPoll,
                                                                             tsc_FI_StartOfSDU,
                                                                             {v_RLC_Data1} )}}};
  p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  v_SubframeDataList[1].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);  // @sic R5s090361 sic@ @sic R5s100002 sic@
  v_SubframeDataList[1].HarqProcess := {Automatic := true};
  v_SubframeDataList[1].PduSduList := { RlcPdu := {{AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                                                             tsc_P_NoPoll,
                                                                             tsc_FI_MiddleOfSDU,
                                                                             {v_RLC_Data2} )}}};
  p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  v_SubframeDataList[2].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);  // @sic R5s090361 sic@ @sic R5s100002 sic@
  v_SubframeDataList[2].HarqProcess := {Automatic := true};
  v_SubframeDataList[2].PduSduList := { RlcPdu := {{AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                                                             tsc_P_NoPoll,
                                                                             tsc_FI_EndOfSDU,
                                                                             {v_RLC_Data3} )}}};
  p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  // 3. send the list of PDUs
  // at least 100 ms to wait for having an accurate reference to start
  // subframe number 0 required to fit with the TDD subframe offsets
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1); // @sic R5s090361 sic@ @sic R5s100039 sic@
  DRB.send (cas_DRB1_RLCAmDataReq_List (eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList));

  //@siclog "Step 7" siclog@
  // 60 ms after step 6 the SS allocates 3 UL grants (UL grant allocation type 2) of size 392 bits. (Note 1).
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, 60 );
  f_EUTRA_PeriodicCyclicULGrantTransmission( eutra_Cell1,
                                             cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                             8,
                                             3,
                                             5, // @sic R5s110394 sic@
                                             3);

  //@siclog "Step 8" siclog@
  // Check: Does the UE return a RLC SDU with equal content as sent in downlink
  // in step 6 segmented into three AMD PDUs where each AMD PDU is received in different TTI?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 44);
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDU_NoLIs (p_RLC_Rec.AM_VRR,
                                                        tsc_P_NoPoll,
                                                        tsc_FI_StartOfSDU,
                                                        {v_RLC_Data1} ))) -> value v_ReceivedAsp;
  v_SubFrameTimingTa := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;  // @sic CR R5-090156 sic@
  // Wait for AMD PDU#2.
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 44, 46);
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDU_NoLIs (p_RLC_Rec.AM_VRR,
                                                        tsc_P_NoPoll,
                                                        tsc_FI_MiddleOfSDU,
                                                        {v_RLC_Data2}))) -> value v_ReceivedAsp;
  v_SubFrameTimingTb := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;  // @sic CR R5-090156 sic@
  // Wait for AMD PDU#3.
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 90, 30);
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDU_NoLIs (p_RLC_Rec.AM_VRR,
                                                        tsc_P_Poll,
                                                        tsc_FI_EndOfSDU,
                                                        {v_RLC_Data3}))) -> value v_ReceivedAsp;
  v_SubFrameTimingTc := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;  // @sic CR R5-090156 sic@
  v_DurationAB := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTa, v_SubFrameTimingTb);
  v_DurationBC := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTb, v_SubFrameTimingTc);
  if (( v_DurationAB > 0 )
      and ( v_DurationBC > 0 ))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 8");
    }
  //@siclog "Step 9" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_2_TestBody

function f_TC_7_2_3_3_EUTRA()
  runs on EUTRA_PTC
{
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 100;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  // closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);

  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  fl_EUTRA_7_2_3_3_TestBody (v_RLC_Rec);
  f_EUTRA_TestBody_Set(false);

  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_3_EUTRA

function fl_EUTRA_7_2_3_3_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{
  var integer i;
  var RLC_DataField_Type v_RLC_Data1;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  p_RLC_Rec.TxDataSize := 100;
  
  // generate 4 RLC SDUs = PDCP PDUs for transmission
  for (i := 0; i < 4; i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 1" siclog@
  // The SS transmits AMD PDU#1 containing a complete RLC SDU#1
  // (FI field = 00).
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, tsc_RLC_SDU1);
  //@siclog "Step 2" siclog@
  // Check: Does the UE transmit RLC SDU#1?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU1);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 2");
  //@siclog "Step 2a" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 3" siclog@
  // The SS transmits AMD PDU#2 containing the first segment of
  // RLC SDU#2 (FI field = 01).  segment of 20 octets
  v_RLC_Data1 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 22);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo_Now,
                 tsc_P_NoPoll,
                 tsc_FI_StartOfSDU,
                 v_RLC_Data1);
  //@siclog "Step 4" siclog@
  // The SS transmits AMD PDU#3 containing the second segment
  // of RLC SDU#2 (FI field = 11).  segment of 50 octets
  v_RLC_Data1 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 22, 50);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo_Now,
                 tsc_P_NoPoll,
                 tsc_FI_MiddleOfSDU,
                 v_RLC_Data1);
  //@siclog "Step 5" siclog@
  // The SS transmits AMD PDU#4 containing the last segment of
  // RLC SDU#2 (FI field = 10).  segment of 30 octets
  v_RLC_Data1 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 72, 30);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo_Now,
                 tsc_P_NoPoll,
                 tsc_FI_EndOfSDU,
                 v_RLC_Data1);
  //@siclog "Step 6" siclog@
  // Check: Does the UE transmit RLC SDU#2?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU2);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 6");
  //@siclog "Step 6a" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 7" siclog@
  // The t_PollRetransmit timer for RLC PDU#5 expires and SS assumes that the transmission
  // of AMD PDU#5 containing a complete RLC SDU#3 and a complete RLC SDU#4 is failed and considers RLC
  // PDU#5 for re-transmission
  f_Delay (p_RLC_Rec.t_PollRetransmit);
  //@siclog "Step 8" siclog@
  // The SS transmits AMD PDU segment containing a complete RLC SDU#3 (FI field = 00).
  // segment of 102 octets, i.e. full SDU
  v_RLC_Data1 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 102);
  f_TxAMD_PDU_OneSeg(p_RLC_Rec,
                     cs_TimingInfo_Now,
                     tsc_P_NoPoll,
                     tsc_FI_FullSDU,
                     tsc_LSF_NotLast,
                     0,
                     v_RLC_Data1);
  //@siclog "Step 9" siclog@
  // Check: Does the UE transmit RLC SDU#3?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU3);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 9");
  //@siclog "Step 9a" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 10" siclog@
  // The SS transmits AMD PDU segment containing the first segment of RLC SDU#4 (FI field = 01).
  // segment of 30 octets
  v_RLC_Data1 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 0, 32);
  f_TxAMD_PDU_OneSeg(p_RLC_Rec,
                     cs_TimingInfo_Now,
                     tsc_P_NoPoll,
                     tsc_FI_StartOfSDU,
                     tsc_LSF_NotLast,
                     102,
                     v_RLC_Data1);
  //@siclog "Step 11" siclog@
  // The SS transmits AMD PDU segment containing the second segment of RLC SDU#4 (FI field = 11).
  // segment of 25 octets
  v_RLC_Data1 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 32, 25);
  f_TxAMD_PDU_OneSeg(p_RLC_Rec,
                     cs_TimingInfo_Now,
                     tsc_P_NoPoll,
                     tsc_FI_MiddleOfSDU,
                     tsc_LSF_NotLast,
                     134,
                     v_RLC_Data1);
  //@siclog "Step 12" siclog@
  // The SS transmits AMD PDU segment containing the last segment of RLC SDU#4 (FI field = 10).
  //segment of 45 octets
  v_RLC_Data1 := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 57, 45);
  f_TxAMD_PDU_OneSeg(p_RLC_Rec,
                     cs_TimingInfo_Now,
                     tsc_P_NoPoll,
                     tsc_FI_EndOfSDU,
                     tsc_LSF_Last,
                     159,
                     v_RLC_Data1);
  //@siclog "Step 13" siclog@
  // Check: Does the UE transmit RLC SDU#4?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU4);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 13");
  //@siclog "Step 14" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_3_TestBody

function f_TC_7_2_3_4_EUTRA()
  runs on EUTRA_PTC
{ // @sic R5s100018 sic@
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 21;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  // @sic R5s100068, R5-1010087 sic@
  fl_EUTRA_GenericRbEst_WithRLC_AM_Params (eutra_Cell1,
                                           {cs_DRB_ToAddMod_RLC_AM (tsc_DRB1,
                                                                    cs_508_DRB_UL_AM_RLC,
                                                                    cds_RX_AM_RLC_Common(ms150, ms60))});
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  // closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(raiseInconc);
  fl_EUTRA_7_2_3_4_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // assigning the default grant again
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_4_EUTRA

function fl_EUTRA_7_2_3_4_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5s100018 sic@
  // @sic R5s100047 sic@ @sic R5s100468 sic@ @sic R5-105016 sic@
  var integer i;
  var RLC_DataField_Type v_RLC_Data1, v_RLC_Data2, v_RLC_Data3;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var SubFrameTiming_Type v_Timing;
  
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  p_RLC_Rec.TxDataSize := 21;
  
  // generate 12 RLC SDUs = PDCP PDUs for transmission
  for (i := 0; i < 12; i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 0" siclog@
  // The SS does not allocate any uplink grant.
  // During the whole test sequence, the SS should not allocate UL grants unless when explicitly stated so in the procedure.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  //@siclog "Step 1" siclog@
  // The SS transmits AMD PDU#1 containing a complete RLC SDU#1 without LI field.
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, tsc_RLC_SDU1);
  //@siclog "Step 2" siclog@
  // The SS transmits an uplink grant allowing the UE to transmit 1 RLC SDU.
  // Provide default grants from this point on
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  //@siclog "Step 3" siclog@
  // Check: Does the UE transmit an AMD PDU containing RLC SDU#1?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU1);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 3");
  //@siclog "Step 3A" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 3B" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  //@siclog "Step 4" siclog@
  // The SS transmits AMD PDU#2 containing a complete RLC SDU#2 and a complete RLC SDU#3 with one LI field.
  //100 ms to wait for having an accurate reference to start
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 23);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 23);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                   tsc_P_NoPoll,
                   tsc_FI_FullSDU,
                   {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 5" siclog@
  // The SS waits for 60 ms then assigns an UL grant sufficient for the UE to loopback RLC SDU#2 and RLC SDU#3.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1,
                                      cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number ));
  //@siclog "Step 6" siclog@
  // Check: Does the UE transmit an AMD PDU containing RLC SDU#2 and RLC SDU#3 in its data field?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 23);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 23);
  f_RxAMD_PDU (p_RLC_Rec,
               tsc_P_Poll,
               tsc_FI_FullSDU,
               cr_FlexPart_1LI (23),
               {v_RLC_Data1, v_RLC_Data2});
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 6");
  //@siclog "Step 7" siclog@
  // SS sends STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 7A" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  //@siclog "Step 8" siclog@
  // The SS transmits AMD PDU#3 containing a complete RLC SDU#4, a complete RLC SDU#5 and a complete RLC
  // SDU#6 with two LI fields.
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 0, 23);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 0, 23);
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU6], 0, 23);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                   tsc_P_NoPoll,
                   tsc_FI_FullSDU,
                   {v_RLC_Data1, v_RLC_Data2, v_RLC_Data3});
  //@siclog "Step 9" siclog@
  // The SS waits for 60 ms then assigns an UL grant sufficient for the UE to loopback RLC SDU#4, RLC SDU#5 and RLC SDU#6.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1,
                                      cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number ));
  //@siclog "Step 10" siclog@
  // Check: Does the UE transmit an AMD PDU containing RLC SDU#4, RLC SDU#5 and RLC SDU#6 in its data field?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 0, 23);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 0, 23);
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU6], 0, 23);
  f_RxAMD_PDU (p_RLC_Rec,
               tsc_P_Poll,
               tsc_FI_FullSDU,
               cr_FlexPart_2LIs (23, 23),
               {v_RLC_Data1, v_RLC_Data2, v_RLC_Data3});
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 10");
  //@siclog "Step 11" siclog@
  // SS sends STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 12" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  //@siclog "Step 13" siclog@
  // The t_PollRetransmit timer for RLC PDU#5 expires and SS assumes that the transmission of AMD PDU#5
  // containing a complete RLC SDU#7, a complete RLC SDU#8, a complete RLC SDU#9, a complete RLC SDU#10, a complete
  // RLC SDU#11 and a complete RLC SDU#12 is failed and consider RLC PDU#5 for re-transmission.
  f_Delay (p_RLC_Rec.t_PollRetransmit);
  //@siclog "Step 14" siclog@
  // The SS transmits AMD PDU segment containing a complete RLC SDU#7 without LI field.
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU7], 0, 23);
  f_TxAMD_PDU_OneSeg(p_RLC_Rec,
                     cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                     tsc_P_NoPoll,
                     tsc_FI_FullSDU,
                     tsc_LSF_NotLast,
                     0,
                     v_RLC_Data1);
  //@siclog "Step 15" siclog@
  // The SS waits for 60ms and then assigns an uplink grant (UL grant allocation type 3) allowing the UE to transmit 1 RLC SDU.
  // Provide one grant of sufficient size
  f_EUTRA_OneULGrantTransmission( eutra_Cell1,
                                  cs_TimingInfo((v_Timing.SFN.Number + 6) mod 1024, v_Timing.Subframe.Number),
                                  7, 6);
  //@siclog "Step 17" siclog@
  // The SS transmits AMD PDU segment containing a complete RLC SDU#8 and a complete RLC SDU#9 with one LI field.
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU8], 0, 23);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU9], 0, 23);
  f_TxAMD_SegList(p_RLC_Rec,
                  cs_TimingInfo((v_Timing.SFN.Number + 7) mod 1024, v_Timing.Subframe.Number),
                  tsc_P_NoPoll,
                  tsc_FI_FullSDU,
                  tsc_LSF_NotLast,
                  23,
                  {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 18" siclog@
  // The SS waits for 60ms and then assigns an uplink grant (UL grant allocation type 3)
  // sufficient for the UE to loopback RLC SDU#8 and RLC SDU#9.
  // Provide one grant of sufficient size
  f_EUTRA_OneULGrantTransmission( eutra_Cell1,
                                  cs_TimingInfo((v_Timing.SFN.Number + 13) mod 1024, v_Timing.Subframe.Number),
                                  7, 6);
  //@siclog "Step 21" siclog@
  // The SS transmits AMD PDU segment containing a complete RLC SDU#10, a complete RLC SDU#11 and a complete RLC
  // SDU#12 with two LI fields.
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU10], 0, 23);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU11], 0, 23);
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU12], 0, 23);
  f_TxAMD_SegList(p_RLC_Rec,
                  cs_TimingInfo((v_Timing.SFN.Number + 14) mod 1024, v_Timing.Subframe.Number),
                  tsc_P_NoPoll,
                  tsc_FI_FullSDU,
                  tsc_LSF_Last,
                  69,
                  {v_RLC_Data1 , v_RLC_Data2, v_RLC_Data3});
  //@siclog "Step 22" siclog@
  // The SS waits for 60 ms then assigns an UL grant (UL grant allocation type 3) sufficient for the UE to loopback RLC SDU#10, RLC SDU#11 and RLC SDU#12.
  // Provide one grant of sufficient size
  f_EUTRA_OneULGrantTransmission( eutra_Cell1,
                                  cs_TimingInfo((v_Timing.SFN.Number + 20) mod 1024, v_Timing.Subframe.Number),
                                  7, 6);
  //@siclog "Step 16" siclog@
  // Check: Does the UE transmit an AMD PDU containing RLC SDU#7?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU7);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 16");
  //@siclog "Step 16A" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 19" siclog@
  // Check: Does the UE transmit an AMD PDU containing RLC SDU#8 and RLC SDU#9 in its data field?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU8], 0, 23);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU9], 0, 23);
  f_RxAMD_PDU (p_RLC_Rec,
               tsc_P_Poll,
               tsc_FI_FullSDU,
               cr_FlexPart_1LI (23),
               {v_RLC_Data1, v_RLC_Data2});
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 19");
  //@siclog "Step 20" siclog@
  // SS sends STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 23" siclog@
  // Check: Does the UE transmit an AMD PDU containing RLC SDU#10, RLC SDU#11 and RLC SDU#12 in its data field?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU10], 0, 23);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU11], 0, 23);
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU12], 0, 23);
  f_RxAMD_PDU (p_RLC_Rec,
               tsc_P_Poll,
               tsc_FI_FullSDU,
               cr_FlexPart_2LIs (23, 23),
               {v_RLC_Data1, v_RLC_Data2, v_RLC_Data3});
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 23");
  //@siclog "Step 24" siclog@
  // SS sends STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 25 void" siclog@
  
} // fl_EUTRA_7_2_3_4_TestBody

function f_TC_7_2_3_5_EUTRA()
  runs on EUTRA_PTC
{ // @sic R5s090217 sic@
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 98;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_1DRB (v_RLC_Rec.UL_PDCP_SDU_size * 8, tsc_DRB1));
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(raiseInconc);
  fl_EUTRA_7_2_3_5_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // assigning the default grant again
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_5_EUTRA

function fl_EUTRA_7_2_3_5_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5s100047 sic@ @sic R5s100279 sic@ @sic R5-105016 sic@
  var integer i;
  var RLC_DataField_Type v_RLC_Data1, v_RLC_Data2, v_RLC_Data3;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;

  var template (value) RLC_Status_NACK_List_Type   v_NACK_List;
  var template (present) RLC_Status_Padding_Type     v_Padding_5bits_Any := '?????'B;
  var SubFrameTiming_Type v_Timing;
  var integer v_Subframe := 0;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  p_RLC_Rec.TxDataSize := 98;

  // generate 3 RLC SDUs = PDCP PDUs
  for (i := 0; i < 3; i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 0" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);

  //@siclog "Step 1" siclog@
  // The SS transmits an AMD PDU containing the first half (50 bytes) of SDU#1 in its data field to the UE.
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 50);
  v_Timing := f_EUTRA_GetNextSendOccasion( eutra_Cell1 );
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                 tsc_P_NoPoll,
                 tsc_FI_StartOfSDU,
                 v_RLC_Data1);

  //@siclog "Step 2" siclog@
  // The SS transmits an AMD PDU containing the second half (50 bytes) of SDU#1 and
  // the first half (50 bytes) of SDU#2 in its data field to the UE.
  // LI associated with PDU#2 has a value > PDU size, i.e. > 100.
  p_RLC_Rec.TxDataSize := 50;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 50, 50);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 50);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                   tsc_P_NoPoll,
                   tsc_FI_MiddleOfSDU,
                   {v_RLC_Data1, v_RLC_Data2},
                   tsc_LI_Error);

  //@siclog "Step 3" siclog@
  // The SS transmits an AMD PDU containing the second half (50 bytes) of SDU#2
  // and the first half (50 bytes) of SDU#3 in its data field to the UE.
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 50, 50);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 50);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                   tsc_P_NoPoll,
                   tsc_FI_MiddleOfSDU,
                   {v_RLC_Data1, v_RLC_Data2});

  //@siclog "Step 4" siclog@
  // The SS transmits an AMD PDU containing the second half (50 bytes)
  // of SDU#3 in its data field to the UE.
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 50, 50);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 3);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                 tsc_P_NoPoll,
                 tsc_FI_EndOfSDU,
                 v_RLC_Data1);

  //@siclog "Step 4A" siclog@
  // 100 ms after step 4 the SS transmits an UL grant (UL grant allocation type 3) of size 56 bits (Note 1).
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, 100 );
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 1, 2); // Imcs = 1 -> Itbs = 1

  //@siclog "Step 5" siclog@
  // Check: Does the UE transmit a STATUS PDU with NACK_SN field set to 1?
  p_RLC_Rec.AM_VTA := 4;
  v_NACK_List := cr_NACK_List(1, tsc_E2_NoSO_Follows, omit);
  f_RxSTATUS_PDU_NACK(p_RLC_Rec, v_NACK_List, v_Padding_5bits_Any);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 5");
  //@siclog "Step 6" siclog@
  // The SS transmits an AMD PDU containing the second half (50 bytes) of SDU#1
  // and the first half (50 bytes) of SDU#2 in its data field to the UE. The LI is correct.
  //100 ms to wait for having an accurate reference to start
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  p_RLC_Rec.AM_VTS := 1;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 50, 50);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 50);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                   tsc_P_NoPoll,
                   tsc_FI_MiddleOfSDU,
                   {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 6A" siclog@
  // SS waits for 60 ms to ensure UE RLC has all the required SDU available in UL for loopback
  //@siclog "Step 6B" siclog@
  // The SS transmits an UL grant (UL grant allocation type 3)  of size 2536 bits.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_OneULGrantTransmission( eutra_Cell1,
                                  cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                  14, 10); // Imcs = 14 -> Itbs = 13
  //@siclog "Step 7" siclog@
  // Check: Does the UE transmit RLC SDU#1, SDU#2, SDU#3?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 100);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 100);
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 100);
  f_RxAMD_PDU (p_RLC_Rec,
               tsc_P_Poll,
               tsc_FI_FullSDU,
               cr_FlexPart_2LIs (100, 100),
               {v_RLC_Data1, v_RLC_Data2, v_RLC_Data3});
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 7");
  //@siclog "Step 8" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_5_TestBody

function f_TC_7_2_3_6_EUTRA()
  runs on EUTRA_PTC
{
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1);  // @sic R5-113673 sic@
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(allowOneRetransmission);  // @sic R5-110792 sic@
  fl_EUTRA_7_2_3_6_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_6_EUTRA

function fl_EUTRA_7_2_3_6_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5-103800r1 sic@ @sic R5s100264 sic@ @sic R5s100279 sic@ @sic R5-105016 sic@ @sic R5-112604 sic@
  var integer i;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (value) DRB_DataPerSubframeList_DL_Type v_SubframeDataList1, v_SubframeDataList2;
  var SubFrameTiming_Type v_Timing;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  var DRB_COMMON_IND v_ReceivedAsp;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  p_RLC_Rec.TxDataSize := 25;
  
  // generate and send 1025 RLC SDUs
  // 1. generate the RLC Data Fields
  for (i := 0; i < 1025; i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  // 2. generate RLC SDUs including subframe timing
  for (i := 0; i < 512; i:= i + 1) {
    v_SubframeDataList1[i].SubframeOffset := (20 * (i mod 512));  // @sic R5-110792 sic@
    v_SubframeDataList1[i].HarqProcess := {Automatic := true};
    v_SubframeDataList1[i].PduSduList := {
      RlcPdu := {
        {
          AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                   tsc_P_NoPoll,
                                   tsc_FI_FullSDU,
                                   { p_RLC_Rec.RLC_DataList[i]} )
        }
      }
    };
    p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  }
  for (i := 512; i < 1024; i:= i + 1) {  // @sic R5s110201 sic@
    v_SubframeDataList2[i-512].SubframeOffset := (20 * (i mod 512));  // @sic R5-110792 sic@
    v_SubframeDataList2[i-512].HarqProcess := {Automatic := true};
    v_SubframeDataList2[i-512].PduSduList := {
      RlcPdu := {
        {
          AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                   tsc_P_NoPoll,
                                   tsc_FI_FullSDU,
                                   { p_RLC_Rec.RLC_DataList[i]} )
        }
      }
    };
    p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  }
  
  //@siclog "Step 0" siclog@
  // During the whole test sequence, the SS shall not allocate UL grants unless when explicitly stated so in the procedure.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  // EXCEPTION: SS is configured 500ms in advance for step 1 and 2.
  // Step 1 is executed 512 times such that 1 AMD PDU is transmitted every second radio frame. (Note 1).
  // Step 2 is started 60 ms after the first DL AMD PDU has been transmitted in step 1 (Note 1).
  //@siclog "Step 1" siclog@
  // The SS transmits an AMD PDU to the UE.
  // SN equals 0 and is incremented for each PDU transmitted (Note 1).
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1, 500);
  DRB.send (cas_DRB1_RLCAmDataReq_List (eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList1));
  
  //@siclog "Step 2" siclog@
  // The SS transmits 1 UL grant (UL grant allocation type 2) in every second radio frame to enable the UE to return
  // each received AMD PDU in one looped back AMD PDU (Note 1).
  // 256 bits = BSR SH + BSR CE     + SDU SH + AMD PDU Hdr + PDCP Hdr + TxData resp.
  // 256 bits = 2 Bytes MAC padding + SDU SH + AMD PDU Hdr + PDCP Hdr + TxData
  // sufficient time is allowed to ensure loop back of data
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_PeriodicULGrantTransmission( eutra_Cell1,
                                       cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                       4,
                                       4,
                                       20);  // Imcs = 4 -> Itbs = 4
  //EXCEPTION:  In parallel to steps 1 and 2, the behaviour described in table 7.2.3.6.3.2-2 is running.
  //@siclog "Parallel behaviour Step 1" siclog@
  // Check: Does the UE transmit an AMD PDU with SN = 0?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU1);
  if (p_RLC_Rec.AM_VRR == 1)
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Parallel behaviour Step 1");
    }
  //@siclog "Parallel behaviour to Steps 1 and 2" siclog@
  // Check: Does the UE transmit an AMD PDU with SN increased by 1 compared with the previous one?
  // IF the UE has set the poll bit in the AMD PDU transmitted at Step 2 THEN the SS transmits a Status Report.
  while (p_RLC_Rec.AM_VRR < 512)  // @sic R5s110201 sic@
  {
    alt {
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                             cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                              tsc_P_NoPoll,
                                                              {p_RLC_Rec.RLC_DataList[p_RLC_Rec.AM_VRR]} )))  -> value v_ReceivedAsp
        {
          p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
          f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Parallel behaviour to Steps 1 and 2 alt 1");
        }
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                             cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                              tsc_P_Poll,
                                                              {p_RLC_Rec.RLC_DataList[p_RLC_Rec.AM_VRR]} ))) -> value v_ReceivedAsp
        {
          p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
          f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Parallel behaviour to Steps 1 and 2 alt 2");
          //@siclog "Parallel behaviour Step 3a1" siclog@
          // Send STATUS PDU upon Poll
          f_TxSTATUS_PDU(p_RLC_Rec);
        }
    }
  }

  //@siclog "Step 2A" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);

  //EXCEPTION:  SS is configured 500ms in advance for step 2B and 2C.
  // Step 2B is executed 512 times such that 1 AMD PDU is transmitted every second radio frame. (Note 1).
  // Step 2C is started 60 ms after the first DL AMD PDU has been transmitted in step 2B (Note 1).
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1, 500); // @sic R5s110201 sic@
  //@siclog "Step 2B" siclog@
  // The SS transmits an AMD PDU to the UE.
  // SN equals 512 and is incremented for each PDU transmitted.
  DRB.send (cas_DRB1_RLCAmDataReq_List (eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList2));

  //@siclog "Step 2C" siclog@
  // The SS transmits 1 UL grant (UL grant allocation type 2) in every second radio frame to enable the UE to return
  // each received AMD PDU in one looped back AMD PDU (Note 1).
  // 256 bits = BSR SH + BSR CE     + SDU SH + AMD PDU Hdr + PDCP Hdr + TxData resp.
  // 256 bits = 2 Bytes MAC padding + SDU SH + AMD PDU Hdr + PDCP Hdr + TxData
  // sufficient time is allowed to ensure loop back of data
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_PeriodicULGrantTransmission( eutra_Cell1,
                                       cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                       4,
                                       4,
                                       20);  // Imcs = 4 -> Itbs = 4

  //EXCEPTION:  In parallel to steps 2B and 2C, the behaviour described in table 7.2.3.6.3.2-3 is running.
  //@siclog "Parallel behaviour to Steps 2B and 2C" siclog@
  // Check: Does the UE transmit an AMD PDU with SN increased by 1 compared with the previous one?
  // IF the UE has set the poll bit in the AMD PDU transmitted at Step 2 THEN the SS transmits a Status Report.
  while (p_RLC_Rec.AM_VRR < 1023)
  {
    alt {
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                             cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                              tsc_P_NoPoll,
                                                              {p_RLC_Rec.RLC_DataList[p_RLC_Rec.AM_VRR]} )))
        {
          p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
          f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Parallel behaviour to Steps 2B and 2C alt 1");
        }
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                             cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                              tsc_P_Poll,
                                                              {p_RLC_Rec.RLC_DataList[p_RLC_Rec.AM_VRR]} )))
        {
          p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
          f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Parallel behaviour to Steps 2B and 2C alt 2");
          //@siclog "Parallel behaviour Step 2a1" siclog@
          // Send STATUS PDU upon Poll
          f_TxSTATUS_PDU(p_RLC_Rec);
        }
    }
  }

  // 1023 AMD PDUs have been exchanged
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_Poll,
                                                       {p_RLC_Rec.RLC_DataList[p_RLC_Rec.AM_VRR]} )));
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Parallel behaviour to Steps 2B and 2C");
  
  //@siclog "Step 2D" siclog@
  // The SS transmits a STATUS PDU with ACK_SN = 0.
  f_TxSTATUS_PDU(p_RLC_Rec);

  //@siclog "Step 3" siclog@
  // The SS transmits an AMD PDU to the UE. SN equals 0.
  if (p_RLC_Rec.AM_VTS != 0)
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 3: Test Case Error");
    }
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, 1024);

  //@siclog "Step 4A" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  
  //@siclog "Step 5" siclog@
  // Check: Does the UE transmit an AMD PDU with SN=0?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, 1024);
  // used only to make the check from the prose explicit
  if (p_RLC_Rec.AM_VRR == 1)
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 5");
    }
  //@siclog "Step 6" siclog@
  // The SS transmits a STATUS PDU with ACK_SN = 1.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_6_TestBody

function f_TC_7_2_3_7_EUTRA()
  runs on EUTRA_PTC
{
  var RLC_SS_State v_RLC_Rec;
  var template (value) PhysicalConfigDedicated v_PhysicalConfigDedicated;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  v_RLC_Rec.pollPDU := 125000; // pollPDU to Infinity
  v_RLC_Rec.pollByte := 12500000; // pollByte to Infinity
  v_RLC_Rec.t_PollRetransmit := 0.3; // t_PollRetransmit to 300 ms  @sic R5s100556 sic@
  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 25;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3 with test case specific RLC parameters, with BSR and PHR disabled, DsrTransMax=n
  // @sic R5-103801r1 sic@    @sic R5-113189 sic@

  //entering UE test state 3, default values with BSR and PHR disabled, DsrTransMax=n8 // @sic R5-110724 sic@ @sic R5-113189 sic@
  v_PhysicalConfigDedicated := f_PhysicalConfigDedicated_Dsr_TransMax( eutra_Cell1, n8 );
  fl_EUTRA_GenericRbEst_WithRLC_AM_Params (eutra_Cell1,
                                           {cs_DRB_ToAddMod_RLC_AM(tsc_DRB1,
                                                                   cds_TX_AM_RLC_no_mRT(ms300, // @sic R5s100466 sic@
                                                                                        pInfinity,
                                                                                        kBinfinity),
                                                                   cs_508_DRB_DL_AM_RLC)},
                                                                   v_PhysicalConfigDedicated);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_1DRB (v_RLC_Rec.UL_PDCP_SDU_size * 8, tsc_DRB1));
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(allowOneRetransmission);  // @sic R5-110792 sic@
  fl_EUTRA_7_2_3_7_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_7_EUTRA

function fl_EUTRA_7_2_3_7_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5-103801r1 sic@  @sic R5s100266 sic@ @sic R5-105016 sic@ @sic R5-112603 sic@
  var integer i;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (value) DRB_DataPerSubframeList_DL_Type v_SubframeDataList;
  var SubFrameTiming_Type v_Timing;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  
  timer t_WatchDog := p_RLC_Rec.t_PollRetransmit/2.0;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  p_RLC_Rec.TxDataSize := 25;
  
  // generate and send 2 * tsc_AM_Window_Size + 3 RLC SDUs
  // 1. generate the RLC Data Fields
  for (i := 0; i < (tsc_AM_Window_Size + 1); i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  // 2. generate tsc_AM_Window_Size + 1 RLC SDUs
  for (i := 0; i < (tsc_AM_Window_Size + 1); i:= i + 1) {
    v_SubframeDataList[i].SubframeOffset := (20 * i);  // @sic R5-110792 sic@
    v_SubframeDataList[i].HarqProcess := {Automatic := true};
    v_SubframeDataList[i].PduSduList := {
      RlcPdu := {
        {
          AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                   tsc_P_NoPoll,
                                   tsc_FI_FullSDU,
                                   {p_RLC_Rec.RLC_DataList[i]} )
        }
      }
    };
    p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  }
  
  //@siclog "Step 0" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);

  // EXCEPTION: SS is configured for step 1 and 1A 500ms in advance.
  // Step 1 is repeated W+1 times, where W = AM_Window_Size.
  // The transmission is performed every second radio frame. (Note 2).
  // Step 1A is started 100 ms after the first DL AMD PDU has been transmitted in step 1.
  //@siclog "Step 1" siclog@
  // The SS transmits an AMD PDU containing a SDU to the UE.
  // at least 100 ms to wait for having an accurate reference to start
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1, 500);
  DRB.send (cas_DRB1_RLCAmDataReq_List (eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList));
  //@siclog "Step 1A" siclog@
  // In the following steps the SS transmits 1 UL grant (UL grant allocation type 2) in every second radio frame
  // to enable the UE to return each received AMD PDU in one looped back AMD PDU. (Note 2).
  // 256 bits = BSR SH + BSR CE     + SDU SH + AMD PDU Hdr + PDCP Hdr + TxData resp.
  // 256 bits = 2 Bytes MAC padding + SDU SH + AMD PDU Hdr + PDCP Hdr + TxData
  // sufficient time is allowed to ensure loop back of data
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 100);   // @sic R5-113189 sic@
  f_EUTRA_PeriodicULGrantTransmission( eutra_Cell1,
                                       cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                       4, 4, 20); // Imcs = 4 -> Itbs = 4  @sic R5-110792 sic@
  // EXCEPTION: In parallel to steps 1 and 1A, the behaviour described in table 7.2.3.7.3.2-2 is running.
  //@siclog "Parallel behaviour Step 1" siclog@
  // The UE transmits an AMD PDU with the same data as received in the corresponding DL AMD PDU.
  // Wait for AmDataInd
  while (p_RLC_Rec.AM_VRR < (tsc_AM_Window_Size - 1)) {
    DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                        cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                         tsc_P_NoPoll,
                                                         {p_RLC_Rec.RLC_DataList[p_RLC_Rec.AM_VRR]} )));
    p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  } // while
  //@siclog "Step 1C" siclog@
  // Check: Does the UE transmit an AMD PDU with the Poll bit set and with the contents of the SDU?
  // get last expected PDU with the P-bit set
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_Poll,
                                                       {p_RLC_Rec.RLC_DataList[p_RLC_Rec.AM_VRR]} )));
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 1C");
  
  //@siclog "Step 1D" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);

  //@siclog "Step 2" siclog@
  // Check: does the UE transmit an AMD PDU within t_poll_retransmit/2?
  // timer value to be used as per configuration (t_PollRetransmit/2)
  t_WatchDog.start;
  alt {
    [] t_WatchDog.timeout
      {
      }
    [] DRB.receive (car_DRB1_RLCAmDataInd(eutra_Cell1, ?)) // catches any SDU
      {
        f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 2");
      }
  } // alt
  
  //@siclog "Step 3" siclog@
  // The SS transmits a STATUS PDU to acknowledge the W uplink AMD PDUs with SN=0 to SN=W-1. ACK_SN = W.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 3A" siclog@
  // Check: Does the UE transmit an AMD PDU with the Poll bit set and with the contents of the (W+1)th SDU?
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_Poll,
                                                       {p_RLC_Rec.RLC_DataList[p_RLC_Rec.AM_VRR]} )));
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 3A");
  
  //@siclog "Step 3B" siclog@
  // The SS transmits a STATUS PDU with ACK_SN=W+1.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_7_TestBody

function f_TC_7_2_3_8_EUTRA()
  runs on EUTRA_PTC
{ // @sic R5s090375 sic@
  var RLC_SS_State v_RLC_Rec;

  //EUTRA initialisation
  f_EUTRA_Init(c1);  // @sic R5s100049 sic@
  // RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  // RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 100;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  // closing the test loop (mode A), entering state 4, with loop back size 0
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_1DRB (0, tsc_DRB1));
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(allowOneRetransmission); // @sic R5-110792 sic@
  fl_EUTRA_7_2_3_8_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);

  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  //postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
  
} // f_TC_7_2_3_8_EUTRA

function fl_EUTRA_7_2_3_8_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5s090375 sic@
  var integer i;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (value) DRB_DataPerSubframeList_DL_Type v_SubframeDataList;
  var B1_Type v_Poll;
  var SubFrameTiming_Type v_Timing;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  
  // TxDataSize set to 20 arbitrarily.  PDCP SDUs of this size will be
  // built, appended to a PDCP header, and then used as RLC SDUs
  p_RLC_Rec.TxDataSize := 20;
  
  // EXCEPTION: SS is configured 500ms in advance for step 1.
  // Step 1 shall be repeated W times, where W is AM_Window_Size.
  // Polling bit enabled for the Wth RLC PDU transmitted.
  // The SS shall set the Sequence Number field for the first AMD PDU to 0
  // and increment it by 1 for every execution of Step 1.
  // The transmission is performed in every second radio frame.

  //@siclog "Step 1" siclog@
  // The SS transmits an AMD PDU to the UE
  //  fl_SendPDUs1toWminus1(p_RLC_Rec, tsc_P_NoPoll);
  
  // generate and send tsc_AM_Window_Size RLC SDUs
  // 1. generate the RLC Data Fields
  // the (w+1) SDU is only created here, but used only later
  for (i := 0; i < (tsc_AM_Window_Size + 1); i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  // 2. generate RLC SDUs
  for (i := 0; i < tsc_AM_Window_Size; i:= i + 1) {
    if ((i+1) == tsc_AM_Window_Size) {
      v_Poll := tsc_P_Poll;
    }
    else {
      v_Poll := tsc_P_NoPoll;
    }
    v_SubframeDataList[i].SubframeOffset := (20 * i);  // @sic R5-110792 sic@
    v_SubframeDataList[i].HarqProcess := {Automatic := true};
    v_SubframeDataList[i].PduSduList := { RlcPdu := {{AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                                                               v_Poll,
                                                                               tsc_FI_FullSDU,
                                                                               {p_RLC_Rec.RLC_DataList[i]} )}}};
    p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  }
  // 3. send the list of SDUs
  // at least 100 ms to wait for having an accurate reference to start
  // subframe number 0 required to fit with the TDD subframe offsets
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1, 500); // @sic R5s120035 sic@
  DRB.send (cas_DRB1_RLCAmDataReq_List (eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList));
  
  //@siclog "Step 2" siclog@
  // Check: does the UE transmit a STATUS PDU acknowledging W
  // PDUs? (ACK_SN = W)
  //a window full of PDUs is to be acknowledged
  p_RLC_Rec.AM_VTA := tsc_AM_Window_Size;
  f_RxSTATUS_PDU_ACK(p_RLC_Rec);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 2");
  //@siclog "Step 3" siclog@
  // The SS transmits the (W+1)th AMD PDU to the UE with the
  // Sequence Number field set to ((2W mod 1024) = 0) and the Polling
  // bit set
  //PDU w + 1 shall display SN = 2 * w and thus be outside the UE's receive window
  p_RLC_Rec.AM_VTS := (2 * tsc_AM_Window_Size) mod 1024;
  f_TxAMD_SDU (p_RLC_Rec, cs_TimingInfo_Now, tsc_P_Poll, tsc_RLC_SDU1);
  //@siclog "Step 4" siclog@
  // Check: does the UE transmit a STATUS PDU acknowledging W
  // PDUs? (ACK_SN = W)
  p_RLC_Rec.AM_VTA := tsc_AM_Window_Size;
  f_RxSTATUS_PDU_ACK(p_RLC_Rec);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 4");
  //@siclog "Step 5" siclog@
  // The SS transmits the (W+2)th AMD PDU to the UE with the
  // Sequence Number field set to W and the Polling bit set.  PDU w +
  // 2 shall display SN = w and thus be inside the UE's receive window
  p_RLC_Rec.AM_VTS := tsc_AM_Window_Size;
  f_TxAMD_SDU (p_RLC_Rec, cs_TimingInfo_Now, tsc_P_Poll, tsc_RLC_SDU2);
  //@siclog "Step 6" siclog@
  // Check: does the UE transmit a STATUS PDU acknowledging W
  // +1 PDUs? (ACK_SN field = W+1) a window full of PDUs is to be
  // acknowledged, no reception at the UE side
  p_RLC_Rec.AM_VTA := 1 + tsc_AM_Window_Size;
  f_RxSTATUS_PDU_ACK(p_RLC_Rec);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 6");
} // fl_EUTRA_7_2_3_8_TestBody

function f_TC_7_2_3_9_EUTRA()
  runs on EUTRA_PTC
{ // @sic R5s100143, R5-112605, R5s110383 sic@
  var RLC_SS_State v_RLC_Rec;
  var template (value) DRB_ToAddModList v_DRB_ToAddModList;
  var template (value) PhysicalConfigDedicated v_PhysicalConfigDedicated;
 
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  v_RLC_Rec.t_PollRetransmit := 0.4; // 400 ms
  v_RLC_Rec.pollPDU := 256; // p256
  v_RLC_Rec.pollByte := 256000; // kB256
  
  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 320;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  // entering UE test state 3 with test case specific RLC parameters, DsrTransmax set to 8
  // and with BSR and PHR disabled
  v_DRB_ToAddModList := {cs_DRB_ToAddMod_RLC_AM (tsc_DRB1,
                                                 cds_TX_AM_RLC_no_mRT (ms400, p256, kB25),
                                                 cs_508_DRB_DL_AM_RLC)};
  v_PhysicalConfigDedicated := f_PhysicalConfigDedicated_Dsr_TransMax( eutra_Cell1, n8);
  f_EUTRA_GenericRbEst_DisableBSR_PHR(eutra_Cell1,
                                      0,
                                      0,
                                      v_DRB_ToAddModList,
                                      omit,
                                      v_PhysicalConfigDedicated,
                                      omit,
                                      omit);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(allowOneRetransmission);
  fl_EUTRA_7_2_3_9_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_9_EUTRA

function fl_EUTRA_7_2_3_9_TestBody(inout RLC_SS_State p_RLC_Rec) runs on EUTRA_PTC
{ // @sic R5-105016 sic@
  var RRC_TransactionIdentifier v_RRC_TI := tsc_RRC_TI_Def;
  var template (value) EUTRA_FDD_TDD_CellInfo_Type  v_EUTRA_FDD_TDD_Info;
  var integer i;
  var DRB_COMMON_IND v_ReceivedAsp;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (value) DRB_DataPerSubframeList_DL_Type v_SubframeDataList;
  var B1_Type v_Poll;
  var integer v_Duration;
  var SubFrameTiming_Type v_SubFrameTimingTa;
  var SubFrameTiming_Type v_SubFrameTimingTb;
  var template (value) RLC_Status_NACK_List_Type   v_NACK_List;
  var RLC_Status_Padding_Type  v_Padding_5bits := '00000'B;
  var SubFrameTiming_Type v_Timing;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  var template (value) PhysicalConfigDedicated_AntennaInfo_Type   v_AntennaInfo;
  
  timer t_WatchDog := 5.0;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  // get FDD_TDD_Info
  v_EUTRA_FDD_TDD_Info:=f_EUTRA_CellInfo_GetFDD_TDD_Info (eutra_Cell1);
  v_AntennaInfo := f_EUTRA_CellInfo_GetAntennaInfoDedicated (eutra_Cell1);
  
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  p_RLC_Rec.TxDataSize := 318; // 318 octets = (2560 bits - 16 bits) / 8
  
  // generate 172 RLC SDUs = PDCP PDUs for transmission
  for (i := 0; i < 172; i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }

  //@siclog "Step 0" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 1" siclog@
  // The SS transmits 4 AMD PDUs, each containing an RLC SDU of size 2560 bits.
  // generate 4 RLC PDUs
  for (i := 0; i < 4; i:= i + 1) {
    if ((i+1) == tsc_AM_Window_Size) {
      v_Poll := tsc_P_Poll;
    }
    else {
      v_Poll := tsc_P_NoPoll;
    }
    v_SubframeDataList[i].SubframeOffset := (20 * (i mod 512));
    v_SubframeDataList[i].HarqProcess := {Automatic := true};
    v_SubframeDataList[i].PduSduList := { RlcPdu := {{AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                                                               v_Poll,
                                                                               tsc_FI_FullSDU,
                                                                               {p_RLC_Rec.RLC_DataList[i]} )}}};
    p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  }
  // send the list of 4 RLC PDUs
  // at least 100 ms to wait for having an accurate reference to start
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  DRB.send (cas_DRB1_RLCAmDataReq_List (eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList));
  //@siclog "Step 1A" siclog@
  // The SS waits for 100 ms, then starts assigning UL grants (UL grant allocation type 2) of size 2600 bits. (Note 1)
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 100);
  f_EUTRA_PeriodicULGrantTransmission( eutra_Cell1,
                                       cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                       15, 9, 20); // Imcs = 15 -> Itbs = 14
  // EXCEPTION: In parallel to the events described in step 1, the steps specified in Table 7.2.3.9.3.2-2 should take place
  // Check: Does the UE transmit 4 AMD PDUs, with only the last one having the poll bit set? Record time TA when the PDU with the poll bit set is received at SS.
  // Record time TA when the PDU with the poll bit set is received at SS.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU1);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU2);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU3);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU4);
  v_SubFrameTimingTa := p_RLC_Rec.TimeStampLastReceivedPDU;
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Parallel behaviour 7.2.3.9.3.2-2");
  
  //@siclog "Step 2" siclog@
  // Check1: does the UE transmit an AMD PDU with with a SN in range 0 to 3 and and P=1?
  // Record time TB.
  // Check 2: (TB - TA) = t-PollRetransmit.
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU_Any((int2bit (0, tsc_AM_SN_Size),
                                                            int2bit (1, tsc_AM_SN_Size),
                                                            int2bit (2, tsc_AM_SN_Size),
                                                            int2bit (3, tsc_AM_SN_Size)),
                                                           tsc_P_Poll,
                                                           ? ))) -> value v_ReceivedAsp;
  v_SubFrameTimingTb := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  v_Duration := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTa, v_SubFrameTimingTb);
  if ( f_EUTRA_SubFrameTimingCheckDuration( eutra_Cell1, l2Timer, v_Duration, float2int(p_RLC_Rec.t_PollRetransmit * 1000.0) ) )
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 2");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 2");
    }
  
  //@siclog "Step 2A" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);

  //@siclog "Step 3" siclog@
  // Upon receiving the Poll, the SS transmits an RLC Status Report.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 4" siclog@
  // Check: does the UE retransmit an AMD PDU within 1 sec ?
  t_WatchDog.start (1.0);
  alt {
    [] t_WatchDog.timeout
      {
      }
    [] DRB.receive (car_DRB1_RLCAmDataInd(eutra_Cell1, ?)) // catches any SDU, not only SDU4
      {
        f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 4");
      }
  } // alt
  
  //@siclog "Step 5" siclog@
  // SS performs an RRC Connection Reconfiguration procedure changing pollPDU to p4.
  f_EUTRA_RRCConnectionReconfiguration_RadioResConfig(eutra_Cell1,
                                                      v_RRC_TI,
                                                      cs_SRB2_1AM_DRB_Reconfig_RLC(v_EUTRA_FDD_TDD_Info.cqi_ReportConfig,
                                                                                   v_EUTRA_FDD_TDD_Info.soundingRS_UL_Config,
                                                                                   v_AntennaInfo,
                                                                                   cds_TX_AM_RLC_no_mRT (ms400, p4, kB25),
                                                                                   cs_508_DRB_DL_AM_RLC));
  p_RLC_Rec.pollPDU := 4; // p4
  //@siclog "Step 5A" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 6" siclog@
  // The SS transmits 8 AMD PDUs such that 1 AMD PDU is sent every second radio frame,
  // each containing an RLC SDU of 2 560 bits. (Note 2)
  // generate 8 RLC PDUs, next 8 of the SDUs generated earlier
  for (i := 0; i < 8; i:= i + 1) {
    if ((i+1) == tsc_AM_Window_Size) {
      v_Poll := tsc_P_Poll;
    }
    else {
      v_Poll := tsc_P_NoPoll;
    }
    v_SubframeDataList[i].SubframeOffset := (20 * (i mod 512));
    v_SubframeDataList[i].HarqProcess := {Automatic := true};
    v_SubframeDataList[i].PduSduList := { RlcPdu := {{AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                                                               v_Poll,
                                                                               tsc_FI_FullSDU,
                                                                               {p_RLC_Rec.RLC_DataList[i+4]} )}}};
    p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  }
  // send the list of 8 RLC PDUs
  // at least 100 ms to wait for having an accurate reference to start
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  DRB.send (cas_DRB1_RLCAmDataReq_List( eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList));
  //@siclog "Step 6A" siclog@
  // The SS waits for 100 ms after the first DL AMD PDU has been transmitted in step 6, then starts assigning
  // UL grants (UL grant allocation type 2) in every second radio frame of size 2600 bits. (Note 1)(Note 2)
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 100);
  f_EUTRA_PeriodicULGrantTransmission( eutra_Cell1,
                                       cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                       15, 9, 20); // Imcs = 15 -> Itbs = 14
  // EXCEPTION: In parallel to the events described in step 6, the steps specified in Table 7.2.3.9.3.2-3
  // should take place.
  // Check: Does the UE transmit 8 AMD PDUs, with the poll bit set only in the 4th and the 8th PDUs?
  
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU5);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU6);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU7);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll,   tsc_RLC_SDU8);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU9);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU10);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU11);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll,   tsc_RLC_SDU12);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Parallel behaviour 7.2.3.9.3.2-3");
  
  //@siclog "Step 7" siclog@
  // The SS sends a Status Report with NACK_SN=0, NACK_SN=1, NACK_SN=2, NACK_SN=4 and NACK_SN=5.
  v_NACK_List := cs_NACK_List_5NACKs_NoSOs(4, 5, 6, 8, 9);
  f_TxSTATUS_PDU_NACK( p_RLC_Rec, v_NACK_List, v_Padding_5bits); // @sic R5s100531 sic@
  
  //@siclog "Step 8" siclog@
  // Check: does the UE transmit AMD PDUs with the following SN and P values:
  // AMD PDU, SN=4, P=0
  // AMD PDU, SN=5, P=0
  // AMD PDU, SN=6, P=0
  // AMD PDU, SN=8, P=0
  // AMD PDU, SN=9, P=1
  p_RLC_Rec.AM_VRR := 4;
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU5);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU6);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU7);
  p_RLC_Rec.AM_VRR := p_RLC_Rec.AM_VRR + 1;
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU9);
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU10);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 8");

  //@siclog "Step 8AA" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);

  //@siclog "Step 8A" siclog@
  // The SS transmits a Status Report with ACK_SN=12 and no NACK_SN.
  p_RLC_Rec.AM_VRR := 12;
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 9" siclog@
  // SS performs a RRC Connection Reconfiguration procedure triggering an RLC-reestablishment
  // of the RLC entity and sets pollPDU to 256.
  // reconfigure DRB at the UE side
  f_EUTRA_RRCConnectionReconfiguration_RadioResConfig(eutra_Cell1,
                                                      v_RRC_TI,
                                                      cs_SRB2_1AM_DRB_Reconfig_RLC(v_EUTRA_FDD_TDD_Info.cqi_ReportConfig,
                                                                                   v_EUTRA_FDD_TDD_Info.soundingRS_UL_Config,
                                                                                   v_AntennaInfo,
                                                                                   cds_TX_AM_RLC_no_mRT (ms400, p256, kB25),
                                                                                   cs_508_DRB_DL_AM_RLC));
  p_RLC_Rec.pollPDU := 256; // p256
  //@siclog "Step 9A" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 10" siclog@
  // After 500 ms the SS transmits 160 AMD PDUs such that 1 AMD PDU is sent every second radio frame,
  // each containing an RLC SDU of size 2560 bits. (Note 2)
  // generate 160 RLC PDUs, next 160 of the SDUs generated earlier
  for (i := 0; i < 160; i:= i + 1) {
    if ((i+1) == tsc_AM_Window_Size) {
      v_Poll := tsc_P_Poll;
    }
    else {
      v_Poll := tsc_P_NoPoll;
    }
    v_SubframeDataList[i].SubframeOffset := (20 * (i mod 512));
    v_SubframeDataList[i].HarqProcess := {Automatic := true};
    v_SubframeDataList[i].PduSduList := { RlcPdu := {{AMD := cs_AMD_PDU_NoLIs (p_RLC_Rec.AM_VTS,
                                                                               v_Poll,
                                                                               tsc_FI_FullSDU,
                                                                               {p_RLC_Rec.RLC_DataList[i+12]} )}}};
    p_RLC_Rec.AM_VTS := (p_RLC_Rec.AM_VTS + 1) mod 1024;
  }
  // send the list of 160 RLC PDUs
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1, 500);
  DRB.send (cas_DRB1_RLCAmDataReq_List( eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList));
  //@siclog "Step 10A" siclog@
  // The SS waits for 100 ms after the first DL AMD PDU has been transmitted in step 10, then starts assigning
  // UL grants (UL grant allocation type 2) in every second radio frame of size 2600 bits. (Note 1)(Note 2)
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 100);
  f_EUTRA_PeriodicULGrantTransmission( eutra_Cell1,
                                       cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                       15, 9, 20); // Imcs = 15 -> Itbs = 14
  // EXCEPTION: In parallel to the events described in step 10, the steps specified in Table 7.2.3.9.3.2-4 should take place
  // Check: Does the UE transmit 160 AMD PDUs, with the poll bit set only in the 79th one, the 158th one and the 160th one?
  for (i := 0; i < 160; i:= i + 1) {
    if (((i+1) == 79) or ((i+1) == 158) or ((i+1) == 160)){
      f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, i+12);
      // The SS transmits an RLC Status Report.
      f_TxSTATUS_PDU(p_RLC_Rec);
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Parallel behaviour 7.2.3.9.3.2-4");
    }
    else {
      f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, i+12);
    }
  }

  //@siclog "Step 10B" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  
} // fl_EUTRA_7_2_3_9_TestBody

function f_TC_7_2_3_10_EUTRA()
  runs on EUTRA_PTC
{ // @sic R5s100031 sic@
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  // overwrite non default values to be used
  v_RLC_Rec.t_Reordering := 0.15;
  v_RLC_Rec.t_StatusProhibit := 0.3;
  v_RLC_Rec.t_PollRetransmit := 0.5;

  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 98;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3 with test case specific RLC parameters, with BSR and PHR disabled
  fl_EUTRA_GenericRbEst_WithRLC_AM_Params (eutra_Cell1,
                                           {cs_DRB_ToAddMod_RLC_AM (tsc_DRB1,
                                                                    cds_TX_AM_RLC_t_PollRetransmit (ms500),
                                                                    cds_RX_AM_RLC_Common (ms150, ms300))});
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA (eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(raiseInconc);
  fl_EUTRA_7_2_3_10_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // assigning the default grant again
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_10_EUTRA

function fl_EUTRA_7_2_3_10_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5-102147 sic@ @sic R5s100116 sic@ @sic R5s100142 sic@ @sic R5-103803 sic@ @sic R5s100224 sic@
  // @sic R5s100279 sic@ @sic R5-105016 sic@
  var integer i;
  var RLC_DataField_Type v_RLC_Data1;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var integer v_Duration;
  var SubFrameTiming_Type v_Timing;
  var SubFrameTiming_Type v_SubFrameTimingTa;
  var SubFrameTiming_Type v_SubFrameTimingTb;
  var SubFrameTiming_Type v_SubFrameTimingTc;
  var SubFrameTiming_Type v_SubFrameTimingT1;
  var SubFrameTiming_Type v_SubFrameTimingT2;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  var integer v_Subframe := 0;
  var DRB_COMMON_IND v_ReceivedAsp;
  var SYSTEM_IND v_ReceivedSysAsp;
  var template (value) RLC_Status_NACK_List_Type v_NACK_List, v_NACK_List1, v_NACK_List2;
  var template (present) RLC_Status_Padding_Type v_Padding_1bit_Any := '?'B;
  var template (present) RLC_Status_Padding_Type v_Padding_5bits_Any := '?????'B;
  
  timer t_WatchDog := 5.0;

  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  p_RLC_Rec.TxDataSize := 98;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  
  // generate 12 RLC SDUs = PDCP PDUs for transmission
  for (i := 0; i < 12; i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 0" siclog@
  // The SS stops the UL grant transmission.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 1" siclog@
  // The SS transmits 4 AMD PDUs with SN=0, 1, 2, and 4 on DRB1.
  // The SS sets the P field of all the AMD PDUs to 0. Record time TA when the AMD PDU with SN=4 is sent.
  //wait for 100ms for sync both in case of FDD and TDD
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU1);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU2);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU3);
  p_RLC_Rec.AM_VTS := 4;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 3);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU5);
  v_SubFrameTimingTa := f_EUTRA_TimingInfoSubframeOffsetAdjust (v_Timing,
                                                                v_Subframe); // @sic R5s110785 sic@
  
  //@siclog "Step 1A" siclog@
  // The SS waits for 60 ms to ensure UE RLC has all the required SDUs available and then assigns 3 UL grants (UL grant allocation type 2) of size 840 bits.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60); // @sic R5s120345, R5-121869 sic@
  f_EUTRA_PeriodicCyclicULGrantTransmission(eutra_Cell1,
                                            cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                            15, 3, 5, 3);  // Imcs = 15 -> Itbs = 14  @sic R5s110394 sic@
  //@siclog "Step 1B" siclog@
  // The UE transmits RLC SDU#1.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU1);
  //@siclog "Step 1C" siclog@
  // The UE transmits RLC SDU#2.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU2);
  //@siclog "Step 1D" siclog@
  // The UE transmits RLC SDU#3.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU3);
  //@siclog "Step 1E" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 1F" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  //@siclog "Step 2" siclog@
  // Check 1: Does the UE transmit a Status Report with NACK_SN=3 and ACK_SN=5?
  // Record time TB
  // Check 2: (TB - TA) = t_Reordering
  p_RLC_Rec.AM_VTA := 5;
  v_NACK_List := cr_NACK_List (3, tsc_E2_NoSO_Follows, omit);
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                             cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                                 v_NACK_List,
                                                                 v_Padding_5bits_Any ))) -> value v_ReceivedAsp
        {
          v_SubFrameTimingTb := v_ReceivedAsp.Common.TimingInfo.SubFrame;
          v_Duration := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTa, v_SubFrameTimingTb);
          if ( f_EUTRA_SubFrameTimingCheckDuration( eutra_Cell1, l2Timer, v_Duration, float2int(p_RLC_Rec.t_Reordering * 1000.0) ) )
            {
              f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 2");
            }
          else
            {
              f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 2");
            };
          t_WatchDog.stop;
        }
    [] t_WatchDog.timeout
      {
        f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 2");
      }
    } // alt

  //@siclog "Step 3" siclog@
  // 100 ms after the Status Report is received at Step 2, the SS transmits 4 AMD PDUs with SN=5, 6, 8 and 9 on DRB 1.
  // The SS sets the P field of all the AMD PDUs to 0.
  v_Timing := v_SubFrameTimingTb;
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 100);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU6);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU7);
  p_RLC_Rec.AM_VTS := 8;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU9);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 3);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU10);
  //@siclog "Step 3A void" siclog@
  //@siclog "Step 3B" siclog@
  // Check 1: Does the UE transmit a Status Report with NACK_SN=3, ACK_SN=7?
  // Record time TC
  // Check 2: (TC - TB) = t_StatusProhibit
  p_RLC_Rec.AM_VTA := 7;
  v_NACK_List := cr_NACK_List (3,
                               tsc_E2_NoSO_Follows,
                               omit);
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                             cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                                 v_NACK_List,
                                                                 v_Padding_5bits_Any ))) -> value v_ReceivedAsp  // @sic R5s100386 sic@
        {
          v_SubFrameTimingTc := v_ReceivedAsp.Common.TimingInfo.SubFrame;
          v_Duration := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTb, v_SubFrameTimingTc);
          if ( f_EUTRA_SubFrameTimingCheckDuration( eutra_Cell1, l2Timer, v_Duration, float2int(p_RLC_Rec.t_StatusProhibit * 1000.0) ) )
            {
              f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 3A");
            }
          else
            {
              f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 3A");
            };
          t_WatchDog.stop;
        }
      [] t_WatchDog.timeout
        {
          f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 3A");
        }
    } // alt
  //@siclog "Step 3C void" siclog@
  //@siclog "Step 4" siclog@
  // Check: does the UE transmit a Status Report with NACK_SN=3, NACK_SN=7 and ACK_SN=10?
  // This will happen after t_StatusProhibit which has already been checked
  p_RLC_Rec.AM_VTA := 10;
  v_NACK_List := cr_NACK_List_2NACKs(3,
                                     tsc_E2_NoSO_Follows,
                                     omit,
                                     7,
                                     tsc_E2_NoSO_Follows,
                                     omit);
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
  {
    [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                           cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                               v_NACK_List,
                                                               v_Padding_1bit_Any ))) -> value v_ReceivedAsp
      {
        t_WatchDog.stop;
      }
    [] t_WatchDog.timeout
      {
        f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 4");
      }
  } // alt

  //@siclog "Step 4A" siclog@
  // The SS stops the UL default grant transmission
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync ( eutra_Cell1, cs_TimingInfo_Now );
  //@siclog "Step 5 void" siclog@
  
  //@siclog "Step 6" siclog@
  // After 300 ms the SS transmits 3 AMD PDUs with SN=3 and SN=7 on DRB 1.
  // The SS sets the P field of all the AMD PDUs to 0 except for that of the AMD PDU with SN=9.
  // t-StatusProhibit = 300 ms => 30 frames
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 300);  // @sic R5s110019, R5s110474 sic@
  p_RLC_Rec.AM_VTS := 3;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU4);
  p_RLC_Rec.AM_VTS := 7;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_Poll,
               tsc_RLC_SDU8);
  //@siclog "Step 6A" siclog@
  // The SS waits for 60 ms to ensure UE RLC has all the required SDUs available and then assigns 1 UL grant (UL grant allocation type 3) of size 40 bits.
  // v_Timing.Subframe.Number of 4 is valid for UL grant transmission
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                                 3, 1);
  //@siclog "Step 7A" siclog@
  // In the next valid subframe following the one scheduled in step 6A the SS  assigns 7 UL grants (UL grant allocation type 2) of size 840 bits.
  // v_Timing.Subframe.Number of 6 (FDD) resp. 9 (TDD) is valid for UL grant transmission
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_EUTRA_PeriodicCyclicULGrantTransmission(eutra_Cell1,
                                            cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                                            15, 3, 5, 7);  // Imcs = 15 -> Itbs = 14  @sic R5s110394 sic@
  //@siclog "Step 7" siclog@
  // Check: does the UE transmit a Status Report with no NACK_SN and ACK_SN = 10?
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                             cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA ) ) )
        {
          t_WatchDog.stop;
          f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 7");
        }
    [] t_WatchDog.timeout
      {
        f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 7");
      }
    } // alt
  //@siclog "Step 7B" siclog@
  // The UE transmits RLC SDU#4.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU4);
  //@siclog "Step 7C" siclog@
  // The UE transmits RLC SDU#5.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU5);
  //@siclog "Step 7D" siclog@
  // The UE transmits RLC SDU#6.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU6);
  //@siclog "Step 7E" siclog@
  // The UE transmits RLC SDU#7.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU7);
  //@siclog "Step 7F" siclog@
  // The UE transmits RLC SDU#8.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU8);
  //@siclog "Step 7G" siclog@
  // The UE transmits RLC SDU#9.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU9);
  //@siclog "Step 7H" siclog@
  // The UE transmits RLC SDU#10.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU10);
  //@siclog "Step 7I" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);

  //@siclog "Step 8 void" siclog@
  
  //@siclog "Step 9" siclog@
  // After 300 ms the SS transmits an AMD PDU with SN=10 and P=0, and an AMD PDU with SN=12 and P=1, on DRB1.
  // t-StatusProhibit = 300 ms => 30 frames
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1, 300);
  v_SubFrameTimingT1 := v_Timing;
  p_RLC_Rec.AM_VTS := 10;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU11], 0, 22);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                 tsc_P_NoPoll,
                 tsc_FI_StartOfSDU,
                 v_RLC_Data1);
  p_RLC_Rec.AM_VTS := 12;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU11], 82, 18);  // @sic R5s110012 sic@
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                 tsc_P_Poll,
                 tsc_FI_EndOfSDU,
                 v_RLC_Data1);
  
  //@siclog "Step 10" siclog@
  // Within t_Reordering/2 ms after Step 9, the SS transmits an AMD PDU with SN=11 and P=0 on DRB1.
  // 60 ms scheduled is less than 150/2 = t_Reordering/2, same subframe as before
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  p_RLC_Rec.AM_VTS := 11;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU11], 22, 60);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                 tsc_P_NoPoll,
                 tsc_FI_MiddleOfSDU,
                 v_RLC_Data1);
  //@siclog "Step 10A" siclog@
  // The SS waits for 60 ms to ensure UE RLC has all the required SDUs available and then assigns 1 UL grant (UL grant allocation type 3) of size 40 bits.
  // v_Timing.Subframe.Number of 4 is valid for UL grant transmission
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                                 3, 1);
  //@siclog "Step 11A" siclog@
  // The SS assigns 1 UL grant (UL grant allocation type 2) of size 840 bits.
  // v_Timing.Subframe.Number of 6 (FDD) resp. 9 (TDD) is valid for UL grant transmission
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                                 15, 3);  // Imcs = 15 -> Itbs = 14  @sic R5s110394 sic@
  //@siclog "Step 9A" siclog@
  // Check: Does the UE transmit a scheduling request within t-Reordering / 2 ms?
  // The trigger will be initiated after 300 ms (see step 9)
  f_SS_ConfigSchedulingRequestIndMode(eutra_Cell1, tsc_L1Mac_IndicationMode_Enable);
  SYSIND.receive(car_SchedulingReq_IND (eutra_Cell1, ?)) -> value v_ReceivedSysAsp;
  f_SS_ConfigSchedulingRequestIndMode(eutra_Cell1, tsc_L1Mac_IndicationMode_Disable);
  v_SubFrameTimingT2 := v_ReceivedSysAsp.Common.TimingInfo.SubFrame;
  v_Duration := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingT1, v_SubFrameTimingT2);
  // sending has been scheduled 300 ms in advance
  // SR would mean that UE reacts upon transmission in step 10
  if ( v_Duration < 60 )
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 9A");
    };
  
  //@siclog "Step 11" siclog@
  // Check: does the UE transmit a Status Report with no NACK_SN and ACK_SN=13?
  p_RLC_Rec.AM_VTA := 13;
  f_RxSTATUS_PDU_ACK (p_RLC_Rec);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 11");
  
  //@siclog "Step 11B" siclog@
  // The UE transmits RLC SDU#11.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU11);
  //@siclog "Step 11C" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);

  //@siclog "Step 12 void" siclog@
  
  //@siclog "Step 13 void" siclog@
  
  //@siclog "Step 14" siclog@
  // The SS transmits an AMD PDU with SN=13 and P=0, and an AMD PDU with SN=19 and P=1, on DRB1.
  // t-StatusProhibit = 300 ms => 30 frames
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1, 300);
  p_RLC_Rec.AM_VTS := 13;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU12], 0, 22);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                 tsc_P_NoPoll,
                 tsc_FI_StartOfSDU,
                 v_RLC_Data1);
  p_RLC_Rec.AM_VTS := 19;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU12], 82, 18);// @sic R5s110012 sic@
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                 tsc_P_Poll,
                 tsc_FI_EndOfSDU,
                 v_RLC_Data1);
  
  //@siclog "Step 15" siclog@
  // The SS waits for t-Reordering ms to ensure expiry.
  
  //@siclog "Step 16 void" siclog@
  //@siclog "Step 17" siclog@
  // 60 ms after step 15 the SS assigns an UL grant (UL grant allocation type 3) of size 56 bits. (Note 3)
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, float2int((0.06 + p_RLC_Rec.t_Reordering)*1000.0) );
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 2, 2); // Imcs = 2 -> Itbs = 1  @sic R5-110718 sic@

  //@siclog "Step 18" siclog@
  // Check: Does the UE transmit a Status Report with ACK_SN=16 and 2 NACK_SNs: 14 and 15?
  v_NACK_List1 := cr_NACK_List_2NACKs (14,
                                       tsc_E2_NoSO_Follows,
                                       omit,
                                       15,
                                       tsc_E2_NoSO_Follows,
                                       omit);
  v_NACK_List2 := cr_NACK_List_4NACKs_NoSOs(14, 15, 16, 17);
  t_WatchDog.start;
  alt // @sic R5-110718 sic@ @sic R5s110168 change 4.2 sic@
  {
    [] DRB.receive(car_DRB1_RLCStatusInd(eutra_Cell1,
                                         cr_STATUS_PDU_Nack(16,
                                                            v_NACK_List1,
                                                            v_Padding_1bit_Any))) -> value v_ReceivedAsp
      {
         f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 18");
      }
    [] DRB.receive(car_DRB1_RLCStatusInd(eutra_Cell1,
                                         cr_STATUS_PDU_Nack(18,
                                                            v_NACK_List2,
                                                            v_Padding_1bit_Any))) -> value v_ReceivedAsp
      {
        f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 18");
      }
    [] t_WatchDog.timeout
      {
        f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 4");
      }
  } // alt
  t_WatchDog.stop;
  //@siclog "Step 19 void" siclog@
  //@siclog "Step 20 void" siclog@
  //@siclog "Step 21" siclog@
  // The SS transmits an AMD PDU with SN=14 and P=1 on DRB1.
  // t-StatusProhibit = 300 ms => 30 frames
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 300);  // @sic R5s110019, @sic R5s110474 sic@
  p_RLC_Rec.AM_VTS := 14;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU12], 22, 20);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                 tsc_P_Poll,
                 tsc_FI_MiddleOfSDU,
                 v_RLC_Data1);
  //@siclog "Step 22" siclog@
  // 60 ms after step 21 the SS assigns an UL grant grant (UL grant allocation type 3) of size 72 bits. (Note 4)
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, 60 );
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 2, 2);

  //@siclog "Step 24" siclog@
  // 60 ms after step 22 the SS transmits 4 AMD PDU with SN=15, 16, 17, 18.
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, 60 );
  p_RLC_Rec.AM_VTS := 15;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU12], 42, 10);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                 tsc_P_NoPoll,
                 tsc_FI_MiddleOfSDU,
                 v_RLC_Data1);
  p_RLC_Rec.AM_VTS := 16;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU12], 52, 10);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                 tsc_P_NoPoll,
                 tsc_FI_MiddleOfSDU,
                 v_RLC_Data1);
  p_RLC_Rec.AM_VTS := 17;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU12], 62, 10);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                 tsc_P_NoPoll,
                 tsc_FI_MiddleOfSDU,
                 v_RLC_Data1);
  p_RLC_Rec.AM_VTS := 18;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU12], 72, 10);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 3);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                 tsc_P_NoPoll,
                 tsc_FI_MiddleOfSDU,
                 v_RLC_Data1);

  //@siclog "Step 24A" siclog@
  // 60 ms after step 24  the SS assigns 1 UL grant (UL grant allocation type 2) of size 840 bits. (Note 1)
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, 60 );
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 15, 3); // @sic R5s110394 sic@

  //@siclog "Step 23" siclog@
  // Check: does the UE transmit a Status Report with ACK_SN=20 and 4 NACK_SNs: 15, 16, 17 and 18?
  p_RLC_Rec.AM_VTA := 20;
  v_NACK_List := cr_NACK_List_4NACKs_NoSOs(15, 16, 17, 18);
  f_RxSTATUS_PDU_NACK( p_RLC_Rec, v_NACK_List, v_Padding_1bit_Any);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 23");

  //@siclog "Step 25" siclog@
  // The UE loopbacks the complete RLC SDU.
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU12);
  //@siclog "Step 26" siclog@
  // The SS transmits a STATUS PDU
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_10_TestBody

function f_TC_7_2_3_13_EUTRA()
  runs on EUTRA_PTC
{ // @sic R5s100145 sic@ @sic R5s102240 sic@ @sic R5-103807 sic@ @sic R5s100224 sic@ @sic R5s100279 sic@
 
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  // test case specific values
  v_RLC_Rec.t_Reordering := 0.15;
  v_RLC_Rec.t_StatusProhibit := 0.3;
  v_RLC_Rec.t_PollRetransmit := 0.4;
  v_RLC_Rec.pollPDU := 125000; // pollPDU to Infinity
  v_RLC_Rec.pollByte := 12500000;// pollByte to Infinity
  
  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 98;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3 with test case specific RLC parameters, with BSR and PHR disabled
  fl_EUTRA_GenericRbEst_WithRLC_AM_Params (eutra_Cell1,
                                           {cs_DRB_ToAddMod_RLC_AM (tsc_DRB1,
                                                                    cds_TX_AM_RLC_no_mRT (ms400, pInfinity, kBinfinity),
                                                                    cds_RX_AM_RLC_Common (ms150, ms300))});
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_1DRB (v_RLC_Rec.UL_PDCP_SDU_size * 8, tsc_DRB1));
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(raiseInconc);
  fl_EUTRA_7_2_3_13_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_13_EUTRA

function fl_EUTRA_7_2_3_13_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5-105016 sic@
  var RRC_TransactionIdentifier v_RRC_TI := tsc_RRC_TI_Def;
  var template (value) EUTRA_FDD_TDD_CellInfo_Type  v_EUTRA_FDD_TDD_Info;
  var integer i;
  var integer v_Duration;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (value) RLC_Status_NACK_List_Type  v_NACK_List;
  var DRB_COMMON_IND v_ReceivedAsp;
  var SubFrameTiming_Type v_SubFrameTimingTa;
  var SubFrameTiming_Type v_SubFrameTimingTb;
  var SubFrameTiming_Type v_SubFrameTimingTc;
  var SubFrameTiming_Type v_SubFrameTimingTd;
  var SubFrameTiming_Type v_SubFrameTimingTe;
  var SubFrameTiming_Type v_SubFrameTimingTf;
  var SubFrameTiming_Type v_SubFrameTimingTg;
  var SubFrameTiming_Type v_SubFrameTimingTh;
  var SubFrameTiming_Type v_SubFrameTimingTi;
  var SubFrameTiming_Type v_SubFrameTimingTj;
  var template (present) RLC_Status_Padding_Type v_Padding_5bits_Any := '?????'B;
  var template (present) RLC_Status_Padding_Type v_Padding_1bit_Any := '?'B;
  var SubFrameTiming_Type v_Timing;
  var integer v_Subframe := 0;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  var template (value) PhysicalConfigDedicated_AntennaInfo_Type v_AntennaInfo;

  timer t_WatchDog := 5.0;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  // get FDD_TDD_Info
  v_EUTRA_FDD_TDD_Info := f_EUTRA_CellInfo_GetFDD_TDD_Info (eutra_Cell1);
  v_AntennaInfo := f_EUTRA_CellInfo_GetAntennaInfoDedicated (eutra_Cell1);

  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  p_RLC_Rec.TxDataSize := 98;
  
  // generate 22 RLC SDUs = PDCP PDUs for transmission
  for (i := 0; i < 22; i:= i + 1)
    {
      f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
      v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
      p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
      p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
    }
  
  //@siclog "Step 1 void" siclog@
  //@siclog "Step 1A" siclog@
  // The SS stops the UL default grant transmission
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync ( eutra_Cell1, cs_TimingInfo_Now );
  //@siclog "Step 2" siclog@
  // The SS transmits 4 AMD PDUs with P=0 and SN=0, 1, 2 and 4.
  // The SS record time TA when AMD PDU 5 (with SN=4) is sent.
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU1);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU2);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU3);
  p_RLC_Rec.AM_VTS := 4;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 3);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU5);
  v_SubFrameTimingTa := f_EUTRA_TimingInfoSubframeOffsetAdjust (v_Timing,
                                                                v_Subframe); // @sic R5s110785 sic@

  //@siclog "Step 2A" siclog@
  // The SS waits for 60 ms to ensure UE RLC has all the required SDUs available and then assigns 3 UL grants of size 840 bits (UL Grant Allocation type 2). (Note 2)
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60); // @sic R5s120345, R5-121869 sic@
  f_EUTRA_PeriodicCyclicULGrantTransmission(eutra_Cell1,
                                            cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                            15, 3, 5, 3 );  // Imcs = 15 -> Itbs = 14  @sic R5s110394 sic@
  //@siclog "Step 2B" siclog@
  // The UE transmits RLC SDU#1.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU1);
  //@siclog "Step 2C" siclog@
  // The UE transmits RLC SDU#2.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU2);
  //@siclog "Step 2D" siclog@
  // The UE transmits RLC SDU#3.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU3);
  //@siclog "Step 2E" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 2F" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  //@siclog "Step 3" siclog@
  // Check1: Does the UE transmit a STATUS PDU with NACK_SN=3 and ACK_SN=5 ? Record time TB.
  // Check2: Is (TB - TA ) = t_Reordering ?
  p_RLC_Rec.AM_VTA := 5;
  v_NACK_List := cr_NACK_List(3, tsc_E2_NoSO_Follows, omit);
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                             cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                                 v_NACK_List,
                                                                 v_Padding_5bits_Any ))) -> value v_ReceivedAsp
        {
          v_SubFrameTimingTb := v_ReceivedAsp.Common.TimingInfo.SubFrame;
          v_Duration := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTa, v_SubFrameTimingTb);
          if ( f_EUTRA_SubFrameTimingCheckDuration( eutra_Cell1, l2Timer, v_Duration, float2int(p_RLC_Rec.t_Reordering * 1000.0) ) )
            {
            }
          else
            {
              f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 3");
            }
          t_WatchDog.stop;
        }
      [] t_WatchDog.timeout
        {
          f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 3");
        }
    } // alt
  //@siclog "Step 4" siclog@
  // 100 ms after the Status Report received at Step 3, the SS sends 4 AMD PDUs with P=0 and SN=5, 6, 8 and 9.
  v_Timing := f_EUTRA_TimingInfoAdd(v_SubFrameTimingTb, 100);  // @sic R5s110019 sic@
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU6);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU7);
  p_RLC_Rec.AM_VTS := 8;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU9);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 3);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU10);
  //@siclog "Step 4A" siclog@
  // Check1: Does the UE transmit a STATUS PDU with NACK_SN=3, NACK_SN=7 and ACK_SN=10 ? Record time TC.
  // Check2: Is (TC - TB ) = t_StatusProhibit ?
  p_RLC_Rec.AM_VTA := 7;
  v_NACK_List := cr_NACK_List ( 3,
                                tsc_E2_NoSO_Follows,
                                omit );
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
  {
    [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                           cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                               v_NACK_List,
                                                               v_Padding_5bits_Any ))) -> value v_ReceivedAsp
       {
         v_SubFrameTimingTc := v_ReceivedAsp.Common.TimingInfo.SubFrame;
         v_Duration := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTb, v_SubFrameTimingTc );
         if( f_EUTRA_SubFrameTimingCheckDuration( eutra_Cell1, l2Timer, v_Duration, float2int(p_RLC_Rec.t_StatusProhibit * 1000.0) ) )
         {
         }
         else
         {
            f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 4B");
         }
         t_WatchDog.stop;
       }
    [] t_WatchDog.timeout
       {
         f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 4B");
       }
  } // alt
  //@siclog "Step 5" siclog@
  // The UE transmits a STATUS PDU with NACK_SN=3, NACK_SN=7 and ACK_SN=10.
  p_RLC_Rec.AM_VTA := 10;
  v_NACK_List := cr_NACK_List_2NACKs ( 3,
                                       tsc_E2_NoSO_Follows,
                                       omit,
                                       7,
                                       tsc_E2_NoSO_Follows,
                                       omit );
  DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                      cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                          v_NACK_List,
                                                          v_Padding_1bit_Any ))) -> value v_ReceivedAsp;
  //@siclog "Step 6" siclog@
  // The SS stops the UL default grant transmission
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync ( eutra_Cell1, cs_TimingInfo_Now );
  //@siclog "Step 7" siclog@
  // After 300ms the SS transmits 3 AMD PDUs with SN=3, 7 and 9. The SS sets the P field of all the AMD PDUs to 0 except for that of the AMD PDU with SN=9.
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 300);  // @sic R5s110019, R5s110474 sic@
  p_RLC_Rec.AM_VTS := 3;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_SDU ( p_RLC_Rec,
                cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                tsc_P_NoPoll,
                tsc_RLC_SDU4 );
  p_RLC_Rec.AM_VTS := 7;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU ( p_RLC_Rec,
                cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                tsc_P_NoPoll,
                tsc_RLC_SDU8 );
  p_RLC_Rec.AM_VTS := 9;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_SDU ( p_RLC_Rec,
                cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                tsc_P_Poll,
                tsc_RLC_SDU10 );
  //@siclog "Step 7A" siclog@
  // The SS waits for 60 ms to ensure UE RLC has all the required SDUs available and then assigns 1 UL grant of size 40 bits (UL Grant Allocation type 3). (Note 2)
  // v_Timing.Subframe.Number of 4 is valid for UL grant transmission
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                                 3, 1);
  //@siclog "Step 8A" siclog@
  // In the next valid subframe following the one scheduled in step 7A the SS assigns 7 UL grants of size 840 bits (UL Grant Allocation type 2). (Note 2)
  // v_Timing.Subframe.Number of 6 (FDD) resp. 9 (TDD) is valid for UL grant transmission
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_EUTRA_PeriodicCyclicULGrantTransmission( eutra_Cell1,
                                             cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                                             15, 3, 5, 7);  // @sic R5s110394 sic@
  //@siclog "Step 8" siclog@
  // The UE transmits a Status Report with no NACK_SN and ACK_SN = 10.
  DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                      cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA ) ) );
 
  //@siclog "Step 8B" siclog@
  // The UE transmits RLC SDU#4.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU4);
  //@siclog "Step 8C" siclog@
  // The UE transmits RLC SDU#5.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU5);
  //@siclog "Step 8D" siclog@
  // The UE transmits RLC SDU#6.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU6);  // @sic R5s100189 sic@
  //@siclog "Step 8E" siclog@
  // The UE transmits RLC SDU#7.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU7);
  //@siclog "Step 8F" siclog@
  // The UE transmits RLC SDU#8.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU8);
  //@siclog "Step 8G" siclog@
  // The UE transmits RLC SDU#9.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU9);  // @sic R5s100189 sic@
  //@siclog "Step 8H" siclog@
  // The UE transmits RLC SDU#10.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU10);
  //@siclog "Step 8I" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 9" siclog@
  // The SS transmits an AMD PDU to the UE
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, tsc_RLC_SDU11);
  //@siclog "Step 9A" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  //@siclog "Step 10" siclog@
  // The UE transmits an AMD PDU with the same data as received in the corresponding DL AMD PDU.
  // The UE sets the poll bit as both the transmission and retransmission buffers become empty. Record time TD.
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_Poll,
                                                       {p_RLC_Rec.RLC_DataList[tsc_RLC_SDU11]} ))) -> value v_ReceivedAsp;
  v_SubFrameTimingTd := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  
  //@siclog "Step 11" siclog@
  // Check1: Does the UE set the poll bit as both the transmission and retransmission buffers become empty? Record time TE.
  // Check2: Is (TE - TD ) = T_poll_retransmit?
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_Poll,
                                                       {p_RLC_Rec.RLC_DataList[tsc_RLC_SDU11]} ))) -> value v_ReceivedAsp;
  v_SubFrameTimingTe := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  v_Duration := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTd, v_SubFrameTimingTe);
  if ( f_EUTRA_SubFrameTimingCheckDuration( eutra_Cell1, l2Timer, v_Duration, float2int(p_RLC_Rec.t_PollRetransmit * 1000.0) ) )
    {
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 11");
    }
  //@siclog "Step 11A" siclog@
  // The SS transmits a STATUS PDU.
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  f_TxSTATUS_PDU(p_RLC_Rec);
   
  //@siclog "Step 12" siclog@
  // The SS reconfigures RLC in the UE and sets.
  p_RLC_Rec.t_Reordering := 0.2;
  p_RLC_Rec.t_StatusProhibit := 0.4;
  p_RLC_Rec.t_PollRetransmit := 0.5;
  // Send RRC CONNECTION RECONFIGURATION to UE
  f_EUTRA_RRCConnectionReconfiguration_RadioResConfig(eutra_Cell1,
                                                      v_RRC_TI,
                                                      cs_SRB2_1AM_DRB_Reconfig_RLC(v_EUTRA_FDD_TDD_Info.cqi_ReportConfig,  // @sic R5-112605: name change sic@
                                                                                   v_EUTRA_FDD_TDD_Info.soundingRS_UL_Config,
                                                                                   v_AntennaInfo,
                                                                                   cds_TX_AM_RLC_no_mRT (ms500, pInfinity, kBinfinity),
                                                                                   cds_RX_AM_RLC_Common (ms200, ms400)));
  //@siclog "Step 11B" siclog@
  // The SS stops the UL default grant transmission
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync ( eutra_Cell1, cs_TimingInfo_Now );  // @sic R5s100189 sic@
  
  //@siclog "Step 13" siclog@
  // The SS transmits 4 AMD PDUs with P=0 and SN=11, 12, 13 and 15.
  // The SS records time TF when AMD PDU 16 (with SN=15) is sent.
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_Timing.Subframe.Number := v_Subframe;
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU12);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU13);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU14);
  p_RLC_Rec.AM_VTS := 15;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 3);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU16);
  v_SubFrameTimingTf := f_EUTRA_TimingInfoSubframeOffsetAdjust (v_Timing,
                                                                v_Subframe); // @sic R5s110785 sic@

  //@siclog "Step 13A" siclog@
  // The SS waits for 60 ms to ensure UE RLC has all the required SDUs available and then assigns 3 UL grants of size 840 bits (UL Grant Allocation type 2). (Note 2)
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60); // @sic R5s120345, R5-121870 sic@
  f_EUTRA_PeriodicCyclicULGrantTransmission(eutra_Cell1,
                                            cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                            15, 3, 5, 3 );  // Imcs = 15 -> Itbs = 14  @sic R5s110394 sic@
  //@siclog "Step 13B" siclog@
  // The UE transmits RLC SDU#12.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU12);
  //@siclog "Step 13C" siclog@
  // The UE transmits RLC SDU#13.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU13);
  //@siclog "Step 13D" siclog@
  // The UE transmits RLC SDU#14.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU14);
  //@siclog "Step 13E" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 13F" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  //@siclog "Step 14" siclog@
  // Check1: Does the UE transmit a STATUS PDU with NACK_SN=14 and ACK_SN=16 ? Record time TG.
  // Check2: Is (TG - TF ) = updated value of t_Reordering ?
  p_RLC_Rec.AM_VTA := 16;
  v_NACK_List := cr_NACK_List(14, tsc_E2_NoSO_Follows, omit);
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                             cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                                 v_NACK_List,
                                                                 v_Padding_5bits_Any ))) -> value v_ReceivedAsp
        {
          v_SubFrameTimingTg := v_ReceivedAsp.Common.TimingInfo.SubFrame;
          v_Duration := f_EUTRA_SubFrameTimingDuration(v_SubFrameTimingTf, v_SubFrameTimingTg);
          if (f_EUTRA_SubFrameTimingCheckDuration( eutra_Cell1, l2Timer, v_Duration, float2int(p_RLC_Rec.t_Reordering * 1000.0) ) )
            {
              f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 14");
            }
          t_WatchDog.stop;
        }
      [] t_WatchDog.timeout
        {
          f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 14");
        }
    } // alt
  //@siclog "Step 15" siclog@
  // 100 ms after the Status Report received at Step 14, the SS sends 4 AMD PDUs with P=0 and SN=16, 17, 19 and 20.
  v_Timing := f_EUTRA_TimingInfoAdd(v_SubFrameTimingTg, 100);  // @sic R5s110019 sic@
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU17);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU18);
  p_RLC_Rec.AM_VTS := 19;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU20);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 3);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
               tsc_P_NoPoll,
               tsc_RLC_SDU21);
  //@siclog "Step 15A" siclog@
  // Check1: Does the UE transmit a STATUS PDU with NACK_SN=14, NACK_SN=18 and ACK_SN=21 ? Record time TH.
  // Check2: Is (TH - TG ) = updated value of t_StatusProhibit ?
  p_RLC_Rec.AM_VTA := 18;
  v_NACK_List := cr_NACK_List ( 14,
                                tsc_E2_NoSO_Follows,
                                omit );
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
  {
    [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                           cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                               v_NACK_List,
                                                               v_Padding_5bits_Any ))) -> value v_ReceivedAsp
       {
         v_SubFrameTimingTh := v_ReceivedAsp.Common.TimingInfo.SubFrame;
         v_Duration := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTg, v_SubFrameTimingTh );
         if( f_EUTRA_SubFrameTimingCheckDuration( eutra_Cell1, l2Timer, v_Duration, float2int(p_RLC_Rec.t_StatusProhibit * 1000.0) ) )
         {
           f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 15B");
         }
         else
         {
           f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 15B");
         }
         t_WatchDog.stop;
       }
    [] t_WatchDog.timeout
       {
         f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 15B");
       }
  } // alt
  //@siclog "Step 16" siclog@
  // The UE transmits a STATUS PDU with NACK_SN=14, NACK_SN=18 and ACK_SN=21.
  p_RLC_Rec.AM_VTA := 21;
  v_NACK_List := cr_NACK_List_2NACKs ( 14,
                                       tsc_E2_NoSO_Follows,
                                       omit,
                                       18,
                                       tsc_E2_NoSO_Follows,
                                       omit );
  DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                      cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                          v_NACK_List,
                                                          v_Padding_1bit_Any ))) -> value v_ReceivedAsp;
  //@siclog "Step 17" siclog@
  // The SS stops the UL default grant transmission
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync ( eutra_Cell1, cs_TimingInfo_Now );
  //@siclog "Step 18" siclog@
  // After 450ms the SS transmits 3 AMD PDUs with SN=14, 18, 20.
  // The SS sets the P field of all the AMD PDUs to 0 except for that of the AMD PDU with SN=20.
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 450);  // @sic R5s110019, R5s110474 sic@
  p_RLC_Rec.AM_VTS := 14;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_SDU ( p_RLC_Rec,
                cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                tsc_P_NoPoll,
                tsc_RLC_SDU15 );
  p_RLC_Rec.AM_VTS := 18;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU ( p_RLC_Rec,
                cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                tsc_P_NoPoll,
                tsc_RLC_SDU19 );
  p_RLC_Rec.AM_VTS := 20;
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_SDU ( p_RLC_Rec,
                cs_TimingInfo(v_Timing.SFN.Number, v_Subframe),
                tsc_P_Poll,
                tsc_RLC_SDU21 );
  //@siclog "Step 18A" siclog@
  // The SS waits for 60 ms to ensure UE RLC has all the required SDUs available and then assigns 1 UL grant of size 40 bits (UL Grant Allocation type 3). (Note 3)
  // v_Timing.Subframe.Number of 4 is valid for UL grant transmission
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                                 3, 1);
  //@siclog "Step 19A" siclog@
  // In the next valid subframe following the one scheduled in step 7A the SS assigns 7 UL grants of size 840 bits (UL Grant Allocation type 2). (Note 3)
  // v_Timing.Subframe.Number of 6 (FDD) resp. 9 (TDD) is valid for UL grant transmission
  v_Subframe := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_EUTRA_PeriodicCyclicULGrantTransmission( eutra_Cell1,
                                             cs_TimingInfo(v_Timing.SFN.Number, v_Subframe ),
                                             15, 3, 5, 7);  // @sic R5s110394 sic@
  //@siclog "Step 19" siclog@
  // The UE transmits a Status Report with no NACK_SN and ACK_SN = 21.
  DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                      cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA )));
  //@siclog "Step 19B" siclog@
  // The UE transmits RLC SDU#15.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU15);
  //@siclog "Step 19C" siclog@
  // The UE transmits RLC SDU#16.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU16);
  //@siclog "Step 19D" siclog@
  // The UE transmits RLC SDU#17.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU17);  // @sic R5s100189 sic@
  //@siclog "Step 19E" siclog@
  // The UE transmits RLC SDU#18.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU18);
  //@siclog "Step 19F" siclog@
  // The UE transmits RLC SDU#19.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU19);
  //@siclog "Step 19G" siclog@
  // The UE transmits RLC SDU#20.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU20);  // @sic R5s100189 sic@
  //@siclog "Step 19H" siclog@
  // The UE transmits RLC SDU#21.
  f_RxAMD_SDU (p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU21);
  //@siclog "Step 19I" siclog@
  // The SS transmits a STATUS PDU.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 20" siclog@
  // The SS transmits an AMD PDU to the UE
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, tsc_RLC_SDU22);
  //@siclog "Step 20A" siclog@
  // The SS starts the UL default grant transmission
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  //@siclog "Step 21" siclog@
  // The UE transmits an AMD PDU with the same data as received in the corresponding DL AMD PDU.
  // The UE sets the poll bit as both the transmission and retransmission buffers become empty. Record time TI.
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_Poll,
                                                       {p_RLC_Rec.RLC_DataList[tsc_RLC_SDU22]} ))) -> value v_ReceivedAsp;
  v_SubFrameTimingTi := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  
  //@siclog "Step 22" siclog@
  // Does the UE set the poll bit as both the transmission and retransmission buffers become empty? Record time TJ.
  // Check2: Is (TJ - TI ) = updated value of t-PollRetransmit?
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_Poll,
                                                       {p_RLC_Rec.RLC_DataList[tsc_RLC_SDU22]} ))) -> value v_ReceivedAsp;
  v_SubFrameTimingTj := v_ReceivedAsp.Common.TimingInfo.SubFrame;
  v_Duration := f_EUTRA_SubFrameTimingDuration( v_SubFrameTimingTi, v_SubFrameTimingTj);
  if ( f_EUTRA_SubFrameTimingCheckDuration( eutra_Cell1, l2Timer, v_Duration, float2int(p_RLC_Rec.t_PollRetransmit * 1000.0) ) )
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 22");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 22");
    }
  //@siclog "Step 23" siclog@
  // The SS transmits a STATUS PDU.
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_13_TestBody

function f_TC_7_2_3_14_EUTRA()
  runs on EUTRA_PTC
{ // @sic R5s100002 sic@
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  // RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  // RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 100;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(raiseInconc);
  fl_EUTRA_7_2_3_14_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  //postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
  
} // f_TC_7_2_3_14_EUTRA

function fl_EUTRA_7_2_3_14_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5s100002 sic@ @sic R5s100279 sic@
  var integer i;
  var RLC_DataField_Type v_RLC_Data1, v_RLC_Data2, v_RLC_Data3;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (present) RLC_Status_Padding_Type v_Padding_1bit_Any := '?'B;
  var template (value) RLC_Status_NACK_List_Type   v_NACK_List;
  var SubFrameTiming_Type v_Timing;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  var integer v_SubframeOffset;
  
  // SDU sizes employed: 100, 40, 130, 80, 150, 90, 200, 120, 60
  var integer v_PDCP_SDU_SizeArray[9]:= {100, 40, 130, 80, 150, 90, 200, 120, 60};
  
  timer t_WatchDog := 5.0;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  
  // generate 9 RLC SDUs = PDCP PDUs
  for (i := 0; i < 9; i:= i + 1) {
    p_RLC_Rec.TxDataSize := v_PDCP_SDU_SizeArray[i];
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 1" siclog@
  // The SS transmits an AMD PDU to the UE.
  // This PDU carries SDU#1.
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, tsc_RLC_SDU1);
  //@siclog "Step 2" siclog@
  // The SS transmits an AMD PDU to the UE.
  // This PDU carries SDU#1.
  p_RLC_Rec.AM_VTS := p_RLC_Rec.AM_VTS - 1;
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, tsc_RLC_SDU1);
  //@siclog "Step 3" siclog@
  // Check: does the UE transmit RLC SDU#1?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU1);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 3");
  //@siclog "Step 3A" siclog@
  // SS sends STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 4" siclog@
  // The SS transmits an AMD PDU to the UE.
  // This PDU contains SDU#2, and the 1st  part of SDU#3.
  // 40 + 2 respectively 80 + 2 octets
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 42);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 82);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo_Now,
                   tsc_P_NoPoll,
                   tsc_FI_StartOfSDU,
                   {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 5" siclog@
  // Check: does the UE transmit RLC SDU#2?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU2);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 5");
  //@siclog "Step 5A" siclog@
  // SS sends STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 6" siclog@
  // The SS transmits an AMD PDU to the UE.
  // This PDU contains SDU#2, and the 1st  part of SDU#3.
  // send PDU established in step 4 once again
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   cs_TimingInfo_Now,
                                   p_RLC_Rec.AMD_PDU));
  //@siclog "Step 7" siclog@
  // Check: does the UE transmit RLC SDU#2?
  t_WatchDog.start;
  alt {
    [] t_WatchDog.timeout
      {
      }
    [] DRB.receive (car_DRB1_RLCAmDataInd(eutra_Cell1, ?)) // catches more than SDU2
      {
        f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 7");
      }
  } // alt
  //@siclog "Step 8" siclog@
  // The SS transmits an AMD PDU to the UE. This PDU contains the 2nd part of SDU#3.
  // This PDU contains the 2nd part of SDU#3.
  // 50 octets
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 82, 50);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo_Now,
                 tsc_P_NoPoll,
                 tsc_FI_EndOfSDU,
                 v_RLC_Data1);
  //@siclog "Step 9" siclog@
  // Check: does the UE transmit RLC SDU#3?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU3);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 9");
  //@siclog "Step 9A" siclog@
  // SS sends STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 11A" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);  // @sic R5s100566 sic@
  // 80 + 2 respectively 60 + 2 octets
  //100 ms to wait for having an accurate reference to start
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  //@siclog "Step 10" siclog@
  // The SS transmits an AMD PDU to the UE.
  // This PDU contains the last part of SDU#6.
  // 70 octets
  p_RLC_Rec.AM_VTS := 5; // SN to be used for the next PDU
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU6], 22, 70);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                 tsc_P_NoPoll,
                 tsc_FI_EndOfSDU,
                 v_RLC_Data1);
  //@siclog "Step 11" siclog@
  // The SS transmits an AMD PDU to the UE.
  // This PDU contains the 2nd part of SDU#5, and the 1st  part of SDU#6.
  // 2nd part of SDU#5 !!!
  // 90 respectively 20 + 2 octets
  p_RLC_Rec.AM_VTS := 4; // SN to be used for the next PDU
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 62, 90);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU6], 0, 22);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                   tsc_P_NoPoll,
                   tsc_FI_MiddleOfSDU,
                   {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 12" siclog@
  // The SS transmits an AMD PDU to the UE.
  // This PDU carries SDU#4 and the 1st part of SDU#5.
  p_RLC_Rec.AM_VTS := 3; // SN to be used for the next PDU
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 0, 82);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 0, 62);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                   tsc_P_NoPoll,
                   tsc_FI_StartOfSDU,
                   {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 12A" siclog@
  // The SS waits for 60 ms then assigns an UL grant sufficient for the UE to loopback SDU#4, SDU#5 and SDU#6.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1,
                                      cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number ));
  //@siclog "Step 13" siclog@
  // Check: Does the UE transmit an AMD PDU containing RLC SDU#4, RLC SDU#5 and RLC SDU#6 in its data field?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 0, 82);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 0, 152);
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU6], 0, 92);
  f_RxAMD_PDU (p_RLC_Rec,
               tsc_P_Poll,
               tsc_FI_FullSDU,
               cr_FlexPart_2LIs (82, 152),
               {v_RLC_Data1, v_RLC_Data2, v_RLC_Data3});
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 13");
  //@siclog "Step 14" siclog@
  // SS sends STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 16" siclog@
  // The SS transmits an AMD RLC PDU to the UE.
  // This PDU contains the last part of SDU#9.
  p_RLC_Rec.AM_VTS := 8; // SN to be used for the next PDU
  p_RLC_Rec.AM_VTA := 9; // set next SN the UE is to expect
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU9], 32, 30);
  f_TxAMD_OnePDU(p_RLC_Rec,
                 cs_TimingInfo_Now,
                 tsc_P_Poll, // @sic R5s100172 sic@
                 tsc_FI_EndOfSDU,
                 v_RLC_Data1);
  //@siclog "Step 17" siclog@
  // Check: Does the UE transmit a STATUS PDU NACK_SN/E1/E2 fields set correctly
  // to inform SS of missing PDUs #7, #8, (ACK_SN = 9, NACK_SN = 6, NACK_SN = 7)?
  v_NACK_List := cr_NACK_List_2NACKs(6,
                                     tsc_E2_NoSO_Follows,
                                     omit,
                                     7,
                                     tsc_E2_NoSO_Follows,
                                     omit);
  f_RxSTATUS_PDU_NACK(p_RLC_Rec,
                      v_NACK_List,
                      v_Padding_1bit_Any);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 17");
  //@siclog "Step 18" siclog@
  // The SS transmits an AMD PDU to the UE.
  // This PDU contains SDU#8, and the 1st  part of SDU#9.
  // 120 + 2 respectively 30 + 2 octets
  //100 ms to wait for having an accurate reference to start
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  p_RLC_Rec.AM_VTS := 7; // SN to be used for the next PDU
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU8], 0, 122);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU9], 0, 32);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_PDU_List(p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                   tsc_P_NoPoll,
                   tsc_FI_StartOfSDU,
                   {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 18A" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  //@siclog "Step 19" siclog@
  // The SS transmits an AMD PDU to the UE.
  // This PDU carries SDU#7.
  // 200 + 2 octets
  p_RLC_Rec.AM_VTS := 6; // SN to be used for the next PDU
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU(p_RLC_Rec,
              cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
              tsc_P_NoPoll,
              tsc_RLC_SDU7);
  //@siclog "Step 19A" siclog@
  // The SS waits for 60 ms then assigns an UL grant sufficient for the UE to loopback SDU#7, SDU#8 and SDU#9.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1,
                                      cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number ));
  //@siclog "Step 20" siclog@
  // Check: Does the UE transmit an AMD PDU containing RLC SDU#7, RLC SDU#8 and RLC SDU#9 in its data field?
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU7], 0, 202);
  v_RLC_Data2 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU8], 0, 122);
  v_RLC_Data3 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU9], 0, 62);
  f_RxAMD_PDU (p_RLC_Rec,
               tsc_P_Poll,
               tsc_FI_FullSDU,
               cr_FlexPart_2LIs (202, 122),
               {v_RLC_Data1, v_RLC_Data2, v_RLC_Data3});
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 20");
  //@siclog "Step 21" siclog@
  // SS sends STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);

} // fl_EUTRA_7_2_3_14_TestBody

function f_TC_7_2_3_15_EUTRA() runs on EUTRA_PTC
{ // @sic R5s100054 sic@
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  // RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  // RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 98;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_1DRB (v_RLC_Rec.UL_PDCP_SDU_size * 8, tsc_DRB1));
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(raiseInconc);
  fl_EUTRA_7_2_3_15_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // assigning the default grant again
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  //postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
  
} // f_TC_7_2_3_15_EUTRA

function fl_EUTRA_7_2_3_15_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5s100279 sic@ @sic R5-105016 sic@
  var integer i;
  var RLC_DataField_Type v_RLC_Data1;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (present) RLC_Status_Padding_Type     v_Padding_1bit_Any := '?'B;
  var template (present) RLC_Status_Padding_Type     v_Padding_7bits_Any := '???????'B;
  var template (value) RLC_Status_NACK_List_Type   v_NACK_List;
  var SubFrameTiming_Type v_Timing;
  var integer v_SubframeOffset;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  var template (value) DRB_DataPerSubframeList_DL_Type v_SubframeDataList;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);
  
  // Data size to be extracted from PRBS: 98
  p_RLC_Rec.TxDataSize := 98;
  // PDCP SDUs of this size will be built, appended to a PDCP header,
  // and then used as RLC SDUs
  // generate 8 RLC SDUs = PDCP PDUs
  for (i := 0; i < 8; i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 0" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 1" siclog@
  // The SS transmits one AMD PDU containing SDU#8 (100 bytes) in its data field to the UE.
  // SN=7 indicates the loss of 7 PDUs.
  p_RLC_Rec.AM_VTS := 7;
  v_SubframeDataList[0].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_SubframeDataList[0].HarqProcess := {Automatic := true};
  v_SubframeDataList[0].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDUoneSDU(p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                    tsc_P_NoPoll,
                                                                                    {p_RLC_Rec.RLC_DataList[tsc_RLC_SDU8]} ))}}};
  //@siclog "Step 2" siclog@
  // The SS transmits one AMD PDU segment containing 50 bvtes of SDU#1 in its data field to the UE.
  // This AMD PDU segment carries part 1 of AMD PDU#1, which contained SDU#1 (100 bytes) in its data field.
  // SO=0 and LSF=0.
  p_RLC_Rec.AM_VTS := 0;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 50);
  v_SubframeDataList[1].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  v_SubframeDataList[1].HarqProcess := {Automatic := true};
  v_SubframeDataList[1].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                         tsc_P_NoPoll,
                                                                                         tsc_FI_StartOfSDU,
                                                                                         tsc_LSF_NotLast,
                                                                                         0,
                                                                                         {v_RLC_Data1} ))}}};
  //@siclog "Step 3" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#2 in its data field to the UE.
  // This AMD PDU segment carries part 2 of AMD PDU#2, which contained SDU#2 (100 bytes) in its data field.
  // SO=50 and LSF=1.
  p_RLC_Rec.AM_VTS := 1;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 50, 50);
  v_SubframeDataList[2].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  v_SubframeDataList[2].HarqProcess := {Automatic := true};
  v_SubframeDataList[2].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                         tsc_P_NoPoll,
                                                                                         tsc_FI_EndOfSDU,
                                                                                         tsc_LSF_Last,
                                                                                         50,
                                                                                         {v_RLC_Data1} ))}}};
  //@siclog "Step 4" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#3 in its data field to the UE.
  // This AMD PDU segment carries part 1 of AMD PDU#3, which contained SDU#3 (100 bytes) in its data field.
  // SO=0 and LSF=0.
  p_RLC_Rec.AM_VTS := 2;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 50);
  v_SubframeDataList[3].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 3);
  v_SubframeDataList[3].HarqProcess := {Automatic := true};
  v_SubframeDataList[3].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                         tsc_P_NoPoll,
                                                                                         tsc_FI_StartOfSDU,
                                                                                         tsc_LSF_NotLast,
                                                                                         0,
                                                                                         {v_RLC_Data1} ))}}};
  //@siclog "Step 5" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#4 in its data field to the UE.
  // This AMD PDU segment carries part 2 of AMD PDU#4, which contained SDU#4 (100 bytes) in its data field.
  // SO=50 and LSF=1.
  p_RLC_Rec.AM_VTS := 3;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 50, 50);
  v_SubframeDataList[4].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 4);
  v_SubframeDataList[4].HarqProcess := {Automatic := true};
  v_SubframeDataList[4].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                         tsc_P_NoPoll,
                                                                                         tsc_FI_EndOfSDU,
                                                                                         tsc_LSF_Last,
                                                                                         50,
                                                                                         {v_RLC_Data1} ))}}};
  //@siclog "Step 6" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#4 in its data field to the UE.
  // This AMD PDU segment carries part 1of AMD PDU#4, which contained SDU#4 (100 bytes) in its data field.
  // SO=0 and LSF=0.
  p_RLC_Rec.AM_VTS := 3;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4], 0, 50);
  v_SubframeDataList[5].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 5);
  v_SubframeDataList[5].HarqProcess := {Automatic := true};
  v_SubframeDataList[5].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                         tsc_P_NoPoll,
                                                                                         tsc_FI_StartOfSDU,
                                                                                         tsc_LSF_NotLast,
                                                                                         0,
                                                                                         {v_RLC_Data1} ))}}};
  //@siclog "Step 7" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#1 in its data field to the UE.
  // This AMD PDU segment carries part 2 of AMD PDU#1, which contained SDU#1 (100 bytes) in its data field.
  // SO=50 and LSF=1.
  p_RLC_Rec.AM_VTS := 0;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 50, 50);
  v_SubframeDataList[6].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 6);
  v_SubframeDataList[6].HarqProcess := {Automatic := true};
  v_SubframeDataList[6].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                         tsc_P_NoPoll,
                                                                                         tsc_FI_EndOfSDU,
                                                                                         tsc_LSF_Last,
                                                                                         50,
                                                                                         {v_RLC_Data1} ))}}};
  //@siclog "Step 8 void" siclog@
  //@siclog "Step 9" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#2 to the UE.
  // This AMD PDU segment carries part 1 of AMD PDU#2, which contained SDU#2 (100 bytes) in its data field.
  // SO=0 and LSF=0.
  p_RLC_Rec.AM_VTS := 1;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 50);
  v_SubframeDataList[7].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 7);
  v_SubframeDataList[7].HarqProcess := {Automatic := true};
  v_SubframeDataList[7].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                         tsc_P_NoPoll,
                                                                                         tsc_FI_StartOfSDU,
                                                                                         tsc_LSF_NotLast,
                                                                                         0,
                                                                                         {v_RLC_Data1} ))}}};
  //@siclog "Step 10 void" siclog@
  //@siclog "Step 11" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#3 in its data field to the UE.
  // This AMD PDU segment carries part 2 of PDU#3, which contained SDU#3 (100 bytes) in its data field.
  // SO=50 and LSF=1.
  p_RLC_Rec.AM_VTS := 2;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 50, 50);
  v_SubframeDataList[8].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 8);
  v_SubframeDataList[8].HarqProcess := {Automatic := true};
  v_SubframeDataList[8].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                         tsc_P_NoPoll,
                                                                                         tsc_FI_EndOfSDU,
                                                                                         tsc_LSF_Last,
                                                                                         50,
                                                                                         {v_RLC_Data1} ))}}};
  //@siclog "Step 11A" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#7 in its data field to the UE.
  // This AMD PDU segment carries part  1 of PDU #7, which contained SDU#7 (100 bytes) in its data field. SO=0 and LSF=0.
  p_RLC_Rec.AM_VTS := 6;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU7], 0, 50);
  v_SubframeDataList[9].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 9);
  v_SubframeDataList[9].HarqProcess := {Automatic := true};
  v_SubframeDataList[9].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                         tsc_P_NoPoll,
                                                                                         tsc_FI_StartOfSDU,
                                                                                         tsc_LSF_NotLast,
                                                                                         0,
                                                                                         {v_RLC_Data1} ))}}};
  //@siclog "Step 11B" siclog@
  // The SS transmits one AMDPDU segment containing 50 bytes of SDU#6 in its data field to the UE.
  // This AMD PDU segment carries segment 2 of AMD PDU#6, which contained SDU#6 (100 bytes) in its data field.
  // SO=50 and LSF=1.
  p_RLC_Rec.AM_VTS := 5;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU6], 50, 50);
  v_SubframeDataList[10].SubframeOffset := f_EUTRA_DataListSubframeOffset(v_EUTRA_FDD_TDD_Mode, 10);
  v_SubframeDataList[10].HarqProcess := {Automatic := true};
  v_SubframeDataList[10].PduSduList := { RlcPdu := {{AMD := valueof(cs_AMD_PDU_seg_NoLIs (p_RLC_Rec.AM_VTS,             // Note: valueof cannot be avoided here
                                                                                          tsc_P_NoPoll,
                                                                                          tsc_FI_EndOfSDU,
                                                                                          tsc_LSF_Last,
                                                                                          50,
                                                                                          {v_RLC_Data1} ))}}};
  // Now send all the list
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  DRB.send (cas_DRB1_RLCAmDataReq_List (eutra_Cell1,
                                        cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                        v_SubframeDataList));
  //@siclog "Step 11C" siclog@
  // The SS waits for 60 ms then SS transmits an uplink grant (UL grant allocation type 2) allowing the UE to transmit 1 RLC SDU.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);  // @sic R5s110558 sic@
  f_EUTRA_PeriodicCyclicULGrantTransmission( eutra_Cell1,
                                             cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                             15, 3, 5, 4);  // @sic R5s110394 sic@
  //@siclog "Step 17" siclog@
  // Wait t_Reordering to run out at the UE side.
  // t_Reordering is 80 ms, Timing has already been incremented by 60 ms
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 20);
  f_EUTRA_StartULGrantTransmissionOnSR_Reception( eutra_Cell1,
                                                  cs_TimingInfo(v_Timing.SFN.Number , v_Timing.Subframe.Number),
                                                  cs_DciInfo_CcchDcchDtchUL_Explicit( 15, 3 ));
  //@siclog "Step 11D" siclog@
  // Check: Does the UE transmit an RLC SDU containing SDU#1 in its data field ?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU1);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 11D");
  
  //@siclog "Step 11E" siclog@
  // Check: Does the UE transmit an RLC SDU containing SDU#2 in its data field ?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU2);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 11E");
  
  //@siclog "Step 12" siclog@
  // Check: Does the UE transmit an RLC SDU  containing SDU#3 in its data field ?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU3);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 12");
  
  //@siclog "Step 13" siclog@
  // Check: Does the UE transmit an RLC SDU  containing SDU#4 in its data field ?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU4);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 13");
  
  //@siclog "Step 14" siclog@
  // The SS transmits an RLC STATUS PDU to the UE.
  // This PDU acks PDUs up to those including SDU#4. ACK_SN=4.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 15 void" siclog@
  //@siclog "Step 16 void" siclog@
  //@siclog "Step 18" siclog@
  // Check: Does the UE transmit a Status Report with NACK_SN=4, NACK_SN=5 with SOStart=0 and SOEnd=49,
  // and  NACK_SN=6 with SOStart=50 and SOEnd=special value, and ACK_SN=8?
  p_RLC_Rec.AM_VTA := 8;
  v_NACK_List := cr_NACK_List_3NACKs(4,
                                     tsc_E2_NoSO_Follows,
                                     omit,
                                     5,
                                     tsc_E2_SO_Follows,
                                     cr_Status_SO(int2bit(0, tsc_AM_SO_Size), int2bit(49, tsc_AM_SO_Size)),
                                     6,
                                     tsc_E2_SO_Follows,
                                     cr_Status_SO(int2bit(50, tsc_AM_SO_Size), tsc_SO_Special));
  f_RxSTATUS_PDU_NACK(p_RLC_Rec, v_NACK_List, v_Padding_1bit_Any);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 18");
  
  //@siclog "Step 18A" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 19" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#7 in its data field to the UE.
  // This AMD PDU segment carries part 2 of AMD PDU#7, which contained SDU#7 (100 bytes) in its data field.
  // SO=50 and LSF=1.
  p_RLC_Rec.AM_VTS := 6;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU7], 50, 50);
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_NoPoll,
                      tsc_FI_EndOfSDU,
                      tsc_LSF_Last,
                      50,
                      v_RLC_Data1);
  
  //@siclog "Step 20" siclog@
  // The SS transmits one AMD PDU segment containing 50 bytes of SDU#6 in its data field to the UE.
  // This AMD PDU segment carries part 1 of AMD PDU#6, which contained SDU#6 (100 bytes) in its data field.
  // SO=0 and LSF=0.
  p_RLC_Rec.AM_VTS := 5;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU6], 0, 50);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_NoPoll,
                      tsc_FI_StartOfSDU,
                      tsc_LSF_NotLast,
                      0,
                      v_RLC_Data1);
  
  //@siclog "Step 21" siclog@
  // The SS transmits one RLC PDU of 50 data bytes to the UE.
  // This AMD PDU segment carries part 1 of AMD PDU#5, which contained SDU#5 (100 bytes) in its data field.
  // SO=0 and LSF=0.
  p_RLC_Rec.AM_VTS := 4;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 0, 50);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_NoPoll,
                      tsc_FI_StartOfSDU,
                      tsc_LSF_NotLast,
                      0,
                      v_RLC_Data1);
  
  //@siclog "Step 22" siclog@
  // Wait t_Reordering to run out at the UE side
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, float2int(p_RLC_Rec.t_Reordering * 1000.0));
  f_EUTRA_StartULGrantTransmissionOnSR_Reception( eutra_Cell1,
                                                  cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                                  cs_DciInfo_CcchDcchDtchUL_Explicit( 15, 3 ));
  //@siclog "Step 23" siclog@
  // Check: Does the UE transmit a Status Report with NACK_SN=4 with SOStart=50
  // and SOEnd=32767 (special SOEnd value), and ACK_SN=8?
  p_RLC_Rec.AM_VTA := 8;
  v_NACK_List := cr_NACK_List(4,
                              tsc_E2_SO_Follows,
                              cr_Status_SO(int2bit(50, tsc_AM_SO_Size), tsc_SO_Special));
  f_RxSTATUS_PDU_NACK(p_RLC_Rec, v_NACK_List, v_Padding_7bits_Any);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 23");

  //@siclog "Step 23A" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 24" siclog@
  // The SS transmits one AMD PDU containing 50 bytes of SDU#5 in its data field to the UE.
  // This AMD PDU segment carries part 2 of AMD PDU#5, which contained SDU#5 (100 bytes) in its data field.
  // SO=50 and LSF=1.
  p_RLC_Rec.AM_VTS := 4;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 50, 50);
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_NoPoll,
                      tsc_FI_EndOfSDU,
                      tsc_LSF_Last,
                      50, v_RLC_Data1);
  
  //@siclog "Step 24A" siclog@
  // The SS waits for 60 ms then SS transmits an uplink grant (UL grant allocation type 2) allowing the UE to transmit 1 RLC SDU.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_PeriodicCyclicULGrantTransmission( eutra_Cell1,
                                             cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                             15, 3, 5, 4);  // @sic R5s110394 sic@
  
  //@siclog "Step 25" siclog@
  // Check: Does the UE transmit an RLC SDU  containing SDU#5 in its data field ?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU5);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 25");
  
  //@siclog "Step 26" siclog@
  // Check: Does the UE transmit an RLC SDU  containing SDU#6 in its data field ?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU6);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 26");
  
  //@siclog "Step 27" siclog@
  // Check: Does the UE transmit an RLC SDU  containing SDU#7 in its data field ?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_NoPoll, tsc_RLC_SDU7);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 27");
  
  //@siclog "Step 28" siclog@
  // Check: Does the UE transmit an RLC SDU  containing SDU#8 in its data field ?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU8);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 28");
  
  //@siclog "Step 29" siclog@
  // The SS transmits an RLC STATUS PDU to the UE.
  // This PDU acks PDUs up to those including SDU#7. ACK_SN=8.
  p_RLC_Rec.AM_VTA := 8;
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_15_TestBody

function f_TC_7_2_3_16_EUTRA()
  runs on EUTRA_PTC
{ // @sic R5s100080 sic@ @sic R5-106680 sic@
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  // RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  // RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 98;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def(eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  //PDCP STATUS REPORT not required
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1, false); // @sic R5s110019 sic@
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_1DRB (v_RLC_Rec.UL_PDCP_SDU_size * 8, tsc_DRB1));
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  fl_EUTRA_7_2_3_16_TestBody (v_RLC_Rec);
  f_EUTRA_TestBody_Set(false);

  //postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);  // @sic R5s100189 sic@ @sic R5s100279 sic@ @sic R5s110019 sic@
  
} // f_TC_7_2_3_16_EUTRA

function fl_EUTRA_7_2_3_16_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{
  var integer i;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (value) RLC_Status_NACK_List_Type   v_NACK_List;
  var RLC_Status_Padding_Type  v_Padding_5bits := '00000'B;
  // determine RAT to make the timing correct later on
  var template (value) EUTRA_FDD_TDD_CellInfo_Type  v_EUTRA_FDD_TDD_Info := f_EUTRA_CellInfo_GetFDD_TDD_Info (eutra_Cell1);
  var template (value) PhysicalConfigDedicated_AntennaInfo_Type v_AntennaInfo := f_EUTRA_CellInfo_GetAntennaInfoDedicated (eutra_Cell1);
  var NextHopChainingCount v_NextHopChainingCount := 0; // Default configuration value according to TS 36.508 Table 4.6.1-10
  var SR_PUCCH_ResourceIndex_Type v_Sr_PUCCH_ResourceIndex := f_EUTRA_CellInfo_GetSR_PUCCH_ResourceIndex ( eutra_Cell1 );
  var SR_ConfigIndex_Type v_SR_ConfigIndex := f_EUTRA_CellInfo_GetSR_ConfigIndex ( eutra_Cell1 );
  var EUTRA_SecurityParams_Type v_Auth_Params;

  timer t_WatchDog := 5.0;

  // Data size to be extracted from PRBS: 98
  p_RLC_Rec.TxDataSize := 98;
  
  //PDCP SDUs of this size will be built, appended to a PDCP header,
  //and then used as RLC SDUs
  
  // generate 3 RLC SDUs = PDCP PDUs
  for (i := 0; i < 3; i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 1" siclog@
  // The SS transmits one AMD PDU containing SDU#1 (100 bytes) in its data field.
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, tsc_RLC_SDU1);
  
  //@siclog "Step 2" siclog@
  // The UE transmits one RLC PDU which carries SDU#1
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU1);
  
  //@siclog "Step 3" siclog@
  // The SS transmits one AMD PDU containing SDU#2 (100 bytes) in its data field.
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, tsc_RLC_SDU2);
  
  //@siclog "Step 4" siclog@
  // The UE transmits one AMD PDU containing SDU#2 in its data field.
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU2);
  
  //@siclog "Step 5" siclog@
  // The SS transmits an RLC STATUS PDU. ACK_SN=2, NACK_SN=0.
  v_NACK_List := cs_NACK_List (0, tsc_E2_NoSO_Follows, omit);
  f_TxSTATUS_PDU_NACK( p_RLC_Rec, v_NACK_List, v_Padding_5bits);

  //@siclog "Step 6" siclog@
  // Check: Does the UE transmit the AMD PDU not yet acknowledged ?
  p_RLC_Rec.AM_VRR := 0;
  f_RxAMD_SDU( p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU1);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 6");
  
  //@siclog "Step 7" siclog@
  // The SS transmits an RLC STATUS PDU. ACK_SN=2.
  p_RLC_Rec.AM_VRR := 2;
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 8" siclog@
  // The SS transmits one AMD PDU containing SDU#3 (100 bytes) in its data field.
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_NoPoll, tsc_RLC_SDU3);
  
  //@siclog "Step 9" siclog@
  // The UE transmits an RLC PDU containing SDU#3 in its data field.
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU3);

  // EXCEPTION: Step 10 to 11 shall be repeated maxRetxThreshold times
  for (i := 0; i < p_RLC_Rec.maxRetxThreshold; i:= i + 1) {
    //@siclog "Step 10" siclog@
    // The SS transmits an RLC STATUS PDU. ACK_SN=3 and NACK_SN=2.
    v_NACK_List := cs_NACK_List(2, tsc_E2_NoSO_Follows, omit); // @sic R5s100430 sic@
    f_TxSTATUS_PDU_NACK( p_RLC_Rec, v_NACK_List, v_Padding_5bits);
    
    //@siclog "Step 11" siclog@
    // Check: Does the UE retransmit the AMD PDU not yet acknowledged ?
    p_RLC_Rec.AM_VRR := 2;
    f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU3);
    f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 11");
  }
  
  //@siclog "Step 12" siclog@
  // The SS transmits an RLC STATUS PDU. ACK_SN=3 and NACK_SN=2.
  v_NACK_List := cs_NACK_List(2, tsc_E2_NoSO_Follows, omit); // @sic R5s100430 sic@
  f_TxSTATUS_PDU_NACK(p_RLC_Rec, v_NACK_List, v_Padding_5bits);

  // After step 12 UE will detect the radio link failure and then after UE will send the RRC Connection Re-establishment
  // but if SS transmit the DL timing advance after radio link failure and before receiving the RRC Connection Re-establishment message
  // then UE will consider this Contention Resolution not successful.
  f_EUTRA_SS_CommonCellConfig(eutra_Cell1, cas_PUCCH_Synch_Config_REQ(eutra_Cell1, cs_TimingInfo_Now, cs_PUCCH_Synch_None));  // @sic R5s110526 sic@
  
  //Reset all RBs
  f_EUTRA_SS_SRBs_DRBs_Reset(eutra_Cell1);   // @sic R5s110423 additional comments sic@
  
  //@siclog "Step 13" siclog@
  // Check: Does the UE transmit an RRC Connection Re-establishment Request ?
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] SRB.receive( car_SRB0_RrcPdu_IND(eutra_Cell1, cr_RRCConnectionReestablishmentRequest_AnyUE( cr_ReestablishmentCause_OtherFailure ) ))
        {
          t_WatchDog.stop;
          f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 13");
        }
      [] t_WatchDog.timeout
        {
         f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 13");
        }
    } // alt

    //Activate RRC security
    v_Auth_Params := f_EUTRA_Security_Get();
    v_Auth_Params := f_EUTRA_SS_AS_ActivateSecurity_HO_Reest ( eutra_Cell1, v_Auth_Params, v_NextHopChainingCount );
    f_EUTRA_Security_Set ( v_Auth_Params );

    //@siclog "Step 14" siclog@
    // The SS transmits RRCConnectionReestablishment message.
    f_EUTRA_RRC_RRCConnectionReestablishment_Def ( eutra_Cell1, -, v_NextHopChainingCount );

    //@siclog "Step 15" siclog@
    // Receive RRCConnectionReestablishmentComplete
    SRB.receive ( car_SRB1_RrcPdu_IND ( eutra_Cell1,  cr_508_RRCConnectionReestablishmentComplete( tsc_RRC_TI_Def ) ) );

    // reconfigure DRB locally to set the required test mode AM mapped to TM
    f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
    p_RLC_Rec.AM_VRR := 0;

    //@siclog "Step 16" siclog@
    // The SS transmits an RRCConnectionReconfiguration message to resume SRB2 and DRB1. @sic R5s110019 sic@
    SRB.send ( cas_SRB1_RrcPdu_REQ ( eutra_Cell1,
                                     cs_TimingInfo_Now,
                                     cs_RRCConnReconfig_Resume_SRB2_DRBs ( tsc_RRC_TI_Def,
                                                                           v_EUTRA_FDD_TDD_Info.cqi_ReportConfig,
                                                                           v_EUTRA_FDD_TDD_Info.soundingRS_UL_Config,
                                                                           v_AntennaInfo,
                                                                           v_Sr_PUCCH_ResourceIndex,
                                                                           v_SR_ConfigIndex) ) );
    //@siclog "Step 17" siclog@
    // The UE transmits an RRCConnectionReconfigurationComplete message.@sic R5s110019 sic@
    interleave {
    []  SRB.receive ( car_SRB1_RrcPdu_IND ( eutra_Cell1, cr_508_RRCConnectionReconfigurationComplete ( tsc_RRC_TI_Def ) ) )
        {}
    // The UE retransmits unacknowledged Data   @sic R5-110832r2 sic@
    []  DRB.receive ( car_DRB1_RLCAmDataInd ( eutra_Cell1,
                                              cr_AMD_PDU_NoLIs(p_RLC_Rec.AM_VRR,
                                                               tsc_P_Poll,
                                                               tsc_FI_FullSDU,
                                                               {p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3]} )))
        {
          p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
        }
    }
    f_TxSTATUS_PDU(p_RLC_Rec);

} // fl_EUTRA_7_2_3_16_TestBody

function f_TC_7_2_3_17_EUTRA()
  runs on EUTRA_PTC
{
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  // RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  // RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 98;
  v_RLC_Rec.t_PollRetransmit := 0.15;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  //t_PollRetransmit set to 150 ms
  fl_EUTRA_GenericRbEst_WithRLC_AM_Params (eutra_Cell1,
                                           {cs_DRB_ToAddMod_RLC_AM (tsc_DRB1,
                                                                    cds_TX_AM_RLC_t_PollRetransmit (ms150),
                                                                    cs_508_DRB_DL_AM_RLC)});
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_1DRB (v_RLC_Rec.UL_PDCP_SDU_size * 8, tsc_DRB1));
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(allowOneRetransmission); // @sic R5-110792 sic@
  fl_EUTRA_7_2_3_17_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);
  
  // assigning the default grant again
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  //postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
  
} // f_TC_7_2_3_17_EUTRA

function fl_EUTRA_7_2_3_17_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5s090219, R5-110792, R5s110168 change 4.2, R5-112755 sic@
  var integer i;
  var integer v_SO, v_SOSeg;
  var DRB_COMMON_IND v_ReceivedAsp;
  var RLC_DataField_Type v_AMD_DataField;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (value) RLC_Status_NACK_List_Type   v_NACK_List;
  var RLC_Status_Padding_Type     v_Padding_5bits := '00000'B;
  var RLC_Status_Padding_Type     v_Padding_7bits := '0000000'B;
  var SubFrameTiming_Type v_Timing;
  timer t_WatchDog := 12.0; // @sic R5s100001 sic@
  
  // Data size to be extracted from PRBS: 98
  p_RLC_Rec.TxDataSize := 98;
  
  // PDCP SDUs of this size will be built, appended to a PDCP header,
  // and then used as RLC SDUs
  
  // generate 2 RLC SDUs = PDCP PDUs
  for (i := 0; i < 2; i:= i + 1) {
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 0" siclog@
  // The SS does not allocate any uplink grant.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);

  //@siclog "Step 1" siclog@
  // The SS transmits one AMD PDU containing SDU#1 (100 bytes) in its data field.
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1);
  f_TxAMD_SDU(p_RLC_Rec,
              cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
              tsc_P_NoPoll,
              tsc_RLC_SDU1);
  
  //@siclog "Step 3" siclog@
  // The SS transmits one AMD PDU containing SDU#2 (100 bytes) in its data field.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 20);
  f_TxAMD_SDU(p_RLC_Rec,
              cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
              tsc_P_NoPoll,
              tsc_RLC_SDU2);
  
  //@siclog "Steps 1A and 3A" siclog@
  // The SS waits for 60 ms and then allocates 2 UL grants (UL grant allocation type 2) of default size
  // such that there is 20ms gap between UL grants
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 40);
  f_EUTRA_PeriodicCyclicULGrantTransmission(eutra_Cell1,
                                            cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                            15, 3, 20, 2); // Imcs = 15 -> Itbs = 14 (840 bits)
  //@siclog "Step 6" siclog@
  // The SS transmits a STATUS PDU. This PDU nacks the AMD PDU with SN=0. NACK_SN=0 and ACK_SN=2.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 40);
  p_RLC_Rec.AM_VRR := 2; // @sic R5s110389 sic@
  v_NACK_List := cs_NACK_List (0, tsc_E2_NoSO_Follows, omit);
  f_TxSTATUS_PDU_NACK(p_RLC_Rec,
                      v_NACK_List,
                      v_Padding_5bits,
                      cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number));
  p_RLC_Rec.AM_VRR := 0; // @sic R5s110389 sic@
  //@siclog "Step 6A" siclog@
  // The SS waits for 20 ms and then allocates 2 UL grants (UL grant allocation type 2) of size 472 bits
  // such that there is 20ms gap between UL grants
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 20);
  f_EUTRA_PeriodicCyclicULGrantTransmission(eutra_Cell1,
                                            cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                            7, 4, 20, 2); // Imcs = 7 -> Itbs = 4

  //@siclog "Step 2" siclog@
  // The UE transmits an AMD PDU with the same data contents as received
  // in the corresponding part of DL PDU#1?
  // Pollbit setting depending upon speed of loop back
  alt
    {
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_NoPoll,
                                                       {p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1]} ))) {};
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_Poll,
                                                       {p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1]} ))) {};
    } // alt
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  
  //@siclog "Step 4" siclog@
  // The UE transmits an AMD PDU with the same data contents as received
  // in the corresponding part of DL PDU#2?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU2);
  
  //@siclog "Step 7" siclog@
  // Check: does the UE transmit an AMD PDU segment with SO=0, LSF=0 and the same data contents
  // at the received positions as in the original AMD PDU?
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                             cr_AMD_PDU_seg (0,
                                                             tsc_P_NoPoll,
                                                             tsc_FI_StartOfSDU,
                                                             tsc_LSF_NotLast,
                                                             0,
                                                             omit,
                                                             ?))) -> value v_ReceivedAsp
        {
          t_WatchDog.stop;
        }
      [] t_WatchDog.timeout
        {
          f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 7");
        }
    } // alt
  v_AMD_DataField := v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].AMD.Data[0];
  v_SO := lengthof(v_AMD_DataField);
  if ( v_AMD_DataField == substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, v_SO) )
  {
    f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 7");
  }
  else
  {
    f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 7");
  }
  
  //@siclog "Step 8" siclog@
  // Check: does the UE transmit an AMD PDU segment with SO=<x>, LSF=1 and the same data contents
  // at the received positions as in the original AMD PDU?
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                             cr_AMD_PDU_seg (0,
                                                             tsc_P_Poll,
                                                             tsc_FI_EndOfSDU,
                                                             tsc_LSF_Last,
                                                             v_SO,
                                                             omit,
                                                             ?))) -> value v_ReceivedAsp
        {
          t_WatchDog.stop;
        }
      [] t_WatchDog.timeout
        {
          f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 8");
        }
    } // alt
  v_AMD_DataField := v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].AMD.Data[0];
  if ( v_AMD_DataField == substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], v_SO, 100 - v_SO) )
  {
    f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 8");  // @sic R5s100001 sic@
  };
  
  //@siclog "Step 10" siclog@
  // After 100ms the SS transmits a STATUS PDU. This PDU nacks the AMD PDU with SN=0. NACK_SN=0,
  // SOStart=0, SOEnd=<x-1> and ACK_SN=2.
  v_NACK_List := cs_NACK_List(0,
                              tsc_E2_SO_Follows,
                              cs_Status_SO(int2bit(0, tsc_AM_SO_Size), int2bit(v_SO - 1, tsc_AM_SO_Size)));
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 100);  // @sic R5s110019, R5s110474 sic@
  f_TxSTATUS_PDU_NACK(p_RLC_Rec,
                      v_NACK_List,
                      v_Padding_7bits,
                      cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number));
  
  //@siclog "Step 10A" siclog@
  // The SS waits for 20 ms and then allocates 2 UL grants (UL grant allocation type 2) of size 328 bits
  // such that there is 20ms gap between UL grants
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 20);
  f_EUTRA_PeriodicCyclicULGrantTransmission(eutra_Cell1,
                                            cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                            5, 4, 20, 2); // Imcs = 5 -> Itbs = 4
  
  //@siclog "Step 11" siclog@
  // Check: does the UE transmit an AMD PDU segment with SO=0, LSF=0 and the same data contents
  // at the received positions as in the original AMD PDU?
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                             cr_AMD_PDU_seg (0,
                                                             tsc_P_NoPoll,
                                                             tsc_FI_StartOfSDU,
                                                             tsc_LSF_NotLast,
                                                             0,
                                                             omit,
                                                             ?))) -> value v_ReceivedAsp
        {
          t_WatchDog.stop;
        }
      [] t_WatchDog.timeout
        {
         f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 11");
        }
      
    } // alt
  v_AMD_DataField := v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].AMD.Data[0];
  v_SOSeg := lengthof(v_AMD_DataField);
  if ( v_AMD_DataField == substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, v_SOSeg) )
  {
    f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 11");
  };

  //@siclog "Step 12" siclog@
  // Check: does the UE transmit an AMD PDU segment with SO=<y>, LSF=0 and the same data contents
  // at the received positions as in the original AMD PDU?
  t_WatchDog.start;
  alt // @sic R5-100050 sic@
    {
      [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                             cr_AMD_PDU_seg (0,
                                                             tsc_P_Poll,
                                                             tsc_FI_MiddleOfSDU,
                                                             tsc_LSF_NotLast,
                                                             v_SOSeg,
                                                             omit,
                                                             ?))) -> value v_ReceivedAsp
        {
          t_WatchDog.stop;
        }
      [] t_WatchDog.timeout
        {
          f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "WatchDog timeout at Step 12");
        }
    } // alt
  v_AMD_DataField := v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].AMD.Data[0];
  if ( v_AMD_DataField == substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], v_SOSeg, v_SO - v_SOSeg) )
  {
    f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 12");
  };
  
  //@siclog "Step 13" siclog@
  // The SS transmits a STATUS PDU. This PDU acks the AMD PDUs with SN=0 and SN=1. ACK_SN=2.
  p_RLC_Rec.AM_VRR := 2;
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_17_TestBody

function f_TC_7_2_3_18_EUTRA()
  runs on EUTRA_PTC
{ // @sic R5s100039 sic@
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 98;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_1DRB (v_RLC_Rec.UL_PDCP_SDU_size * 8, tsc_DRB1));

  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  f_EUTRA_HarqErrorHandling_Set(raiseInconc);
  fl_EUTRA_7_2_3_18_TestBody (v_RLC_Rec);
  f_EUTRA_HarqErrorHandling_Set(ignore);
  f_EUTRA_TestBody_Set(false);

  // assigning the default grant again
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_18_EUTRA

function fl_EUTRA_7_2_3_18_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ // @sic R5s100279 sic@ @sic R5-105016 sic@
  var integer i;
  var RLC_DataField_Type v_RLC_Data1, v_RLC_Data2, v_RLC_Data3;
  var integer v_SDU_Size := 98;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var template (value) RLC_Status_NACK_List_Type  v_NACK_List, v_NACK_List1;
  var template (present) RLC_Status_Padding_Type v_Padding_3bits_Any := '???'B;
  var template (present) RLC_Status_Padding_Type v_Padding_5bits_Any := '?????'B;
  var template (present) RLC_Status_Padding_Type v_Padding_7bits_Any := '???????'B;
  var RLC_DataField_Type v_AMD_SDUs3And4;
  var RLC_DataField_Type v_AMD_SDUs8To10;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  var DRB_COMMON_IND v_ReceivedAsp;
  var SubFrameTiming_Type v_Timing;
  var integer v_SubframeOffset;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);

  // PDCP SDUs of size 98 will be built, appended to a PDCP header,
  // and then used as RLC SDUs
  
  // generate 10 RLC SDUs = PDCP PDUs
  for (i := 0; i < 10; i:= i + 1) {
    p_RLC_Rec.TxDataSize := v_SDU_Size;
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 1" siclog@
  // The SS transmits an AMD PDU containing the first half (50 bytes) of SDU#1 in its data field.
  // This PDU is in error (SN falls outside of the receiving window) and is to be discarded by the UE.
  p_RLC_Rec.AM_VTS := p_RLC_Rec.AM_VTS + tsc_AM_Window_Size + 3;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 50);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_NoPoll,
                  tsc_FI_StartOfSDU,
                  v_RLC_Data1);
  
  //@siclog "Step 2" siclog@
  // The SS transmits an AMD PDU containing SDU#2 (100 bytes) in its data field with the P-bit set.
  p_RLC_Rec.AM_VTS := 1;
  f_TxAMD_SDU(p_RLC_Rec, cs_TimingInfo_Now, tsc_P_Poll, tsc_RLC_SDU2);
  
  //@siclog "Step 3" siclog@
  // The UE transmits a STATUS PDU with NACK_SN field indicating missing PDU#1.
  p_RLC_Rec.AM_VTA := 2;
  v_NACK_List := cr_NACK_List (0, tsc_E2_NoSO_Follows, omit);
  f_RxSTATUS_PDU_NACK(p_RLC_Rec, v_NACK_List, v_Padding_5bits_Any);
  //@siclog "Step 3A" siclog@
  // The SS does not allocate any uplink grant.
  // from now on everything is scheduled ...
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync(eutra_Cell1, cs_TimingInfo_Now);
  
  //@siclog "Step 4" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#1 (AMD PDU#1 carries SDU#1) containing the
  // first 50 bytes of SDU#1 in its data field. SO=0 and LSF=0. No header extension part is provided.
  p_RLC_Rec.AM_VTS := 0;
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(p_RLC_Rec.TimeStampLastReceivedPDU, 100);  // @sic R5s110019, R5s110474 sic@
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 50);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_NoPoll,
                      tsc_FI_StartOfSDU,
                      tsc_LSF_NotLast,
                      0,
                      v_RLC_Data1);
  //@siclog "Step 5" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#1 (AMD PDU#1 carries SDU#1) containing the last
  // 50 bytes of SDU#1 in its data field with the P-bit set. SO=50 and LSF=1. No header extension part is provided.
  p_RLC_Rec.AM_VTS := 0;
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 50, 50);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_Poll,
                      tsc_FI_EndOfSDU,
                      tsc_LSF_Last,
                      50,
                      v_RLC_Data1);
  //@siclog "Step 5A" siclog@
  // SS waits for 60 ms to ensure UE RLC has all the required SDUs available in UL for loopback and then assigns one default grant (UL grant allocation type 3).
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 9, 25);
  //@siclog "Step 6" siclog@
  // Check: Does the UE transmit a STATUS PD     with ACK_SN=2, thus acknowledging the reception of
  // PDUs with SN=0 and SN=1, and  no NACK_SN provided ?
  p_RLC_Rec.AM_VTA := 2;
  // receive STATUS PDU + DATA PDU in the same TTI, thus in a list
  DRB.receive (car_DRB1_RLCAmStatusAndDataInd( eutra_Cell1,
                                               ?,
                                               ?)) -> value v_ReceivedAsp;
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].Status,
             cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA )))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 6");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 6");
    }
  //@siclog "Step 7" siclog@
  // Check: Does the UE transmit RLC SDU#1?
  v_RLC_Data1 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1];
  v_RLC_Data2 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2];
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[1].AMD,
             cr_AMD_PDU_LIs (p_RLC_Rec.AM_VRR,
                             tsc_P_Poll,
                             tsc_FI_FullSDU,
                             cr_FlexPart_1LI (100),
                             {v_RLC_Data1, v_RLC_Data2})))
    {
      p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 7");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 7");
    }
  //@siclog "Step 8 void" siclog@
  
  //@siclog "Step 8A" siclog@ Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 9" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#3 (AMD PDU#3 carries SDU#3 and SDU#4) containing the last
  // 50 bytes of SDU#4 in its data field, with the P-bit set. FI=10, SO=150 and LSF=1. No header extension part is provided.
  v_AMD_SDUs3And4 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3] & p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4];
  p_RLC_Rec.AM_VTS := 2;
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 100);  // @sic R5s110019, R5s110474 sic@
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_RLC_Data1 := substr (v_AMD_SDUs3And4, 150, 50);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_Poll,
                      tsc_FI_EndOfSDU,
                      tsc_LSF_Last,
                      150,
                      v_RLC_Data1);
  //@siclog "Step 9A" siclog@
  // 100 ms after step 9  the SS assigns one default grant (UL grant allocation type 3).
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, 100 );
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 9, 25);

  //@siclog "Step 10" siclog@
  // The UE transmits a STATUS PDU NACK_SN field for receipt of PDU#3.
  p_RLC_Rec.AM_VTA := 3;
  v_NACK_List := cr_NACK_List (2,
                               tsc_E2_SO_Follows,
                               cr_Status_SO(int2bit(0, tsc_AM_SO_Size), int2bit(149, tsc_AM_SO_Size)));
  f_RxSTATUS_PDU_NACK(p_RLC_Rec, v_NACK_List, v_Padding_7bits_Any);
  
  //@siclog "Step 11" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#3 (AMD PDU#3 carries SDU#3 and SDU#4) containing SDU#3 (100 bytes)
  // and the first 50 bytes of SDU#4 in its data field, with the P-bit set. FI=01, SO=0 and LSF=0.
  // Header extension part present: E in fixed part header=1, E in extension part header=0, LI=100.
  p_RLC_Rec.AM_VTS := 2;
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(p_RLC_Rec.TimeStampLastReceivedPDU, 100);  // @sic R5s110019, R5s110474 sic@
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_RLC_Data1 := substr (v_AMD_SDUs3And4, 0, 100);
  v_RLC_Data2 := substr (v_AMD_SDUs3And4, 100, 50);
  f_TxAMD_SegList (p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                   tsc_P_Poll,
                   tsc_FI_StartOfSDU,
                   tsc_LSF_NotLast,
                   0,
                   {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 11A" siclog@
  // The SS waits for 60 ms to ensure UE RLC has all the required SDUs available in UL for loopback and then assigns one default grant
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 9, 25);
  //@siclog "Step 12" siclog@
  // Check: Does the UE transmit a STATUS PDU with ACK_SN=3?
  p_RLC_Rec.AM_VTA := 3;
  // receive STATUS PDU + DATA PDU in the same TTI, thus in a list
  DRB.receive (car_DRB1_RLCAmStatusAndDataInd( eutra_Cell1,
                                               ?,
                                               ?)) -> value v_ReceivedAsp;
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].Status,
             cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA )))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 12");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 12");
    }
  //@siclog "Step 13 void" siclog@
  //@siclog "Step 14" siclog@
  // Check: Does the UE transmit RLC SDU#4?
  v_RLC_Data1 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3];
  v_RLC_Data2 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU4];
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[1].AMD,
             cr_AMD_PDU_LIs (p_RLC_Rec.AM_VRR,
                             tsc_P_Poll,
                             tsc_FI_FullSDU,
                             cr_FlexPart_1LI (100),
                             {v_RLC_Data1, v_RLC_Data2})))
    {
      p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 14");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 14");
    }
  //@siclog "Step 14A" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 15" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#4 (AMD PDU#4 carries SDU#5) containing the
  // first 50 bytes of SDU#5 in its data field. SO=0 and LSF=0. No header extension part is provided.
  p_RLC_Rec.AM_VTS := 3;
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 100);  // @sic R5s110019, R5s110474 sic@
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 0, 50);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_NoPoll,
                      tsc_FI_StartOfSDU,
                      tsc_LSF_NotLast,
                      0,
                      v_RLC_Data1);
  
  //@siclog "Step 16" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#4 (AMD PDU#4 carries SDU#5) containing the
  // first 50 bytes of SDU#5 in its data field. SO=0 and LSF=0. No header extension part is provided.
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                                   p_RLC_Rec.AMD_PDU));
  //@siclog "Step 17" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#4 (AMD PDU#4 carries SDU#5) containing the last
  // 50 bytes of SDU#5 in its data field, with the P-bit set. SO=50 and LSF=1. No header extension part is provided.
  p_RLC_Rec.AM_VTS := 3;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5], 50, 50);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_Poll,
                      tsc_FI_EndOfSDU,
                      tsc_LSF_Last,
                      50,
                      v_RLC_Data1);
  //@siclog "Step 17A" siclog@
  // SS waits for 60 ms to ensure UE RLC has all the required SDUs available in UL for loopback and then assigns one default grant (UL grant allocation type 3).
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                   9, 25);
  //@siclog "Step 18" siclog@
  // Check: Does the UE transmit a STATUS PDU with  ACK_SN=4, thus acknowledging the reception of
  // PDUs with SN=0 to SN=3, and no NACK_SN provided ?
  p_RLC_Rec.AM_VTA := 4;
  // receive STATUS PDU + DATA PDU in the same TTI, thus in a list
  DRB.receive (car_DRB1_RLCAmStatusAndDataInd( eutra_Cell1,
                                               ?,
                                               ?)) -> value v_ReceivedAsp;
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].Status,
             cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA )))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 18");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 18");
    }
  //@siclog "Step 19" siclog@
  // Check: Does the UE transmit RLC SDU#5?
  v_RLC_Data1 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU5];
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[1].AMD,
             cr_AMD_PDU_NoLIs (p_RLC_Rec.AM_VRR,
                               tsc_P_Poll,
                               tsc_FI_FullSDU,
                               {v_RLC_Data1})))
    {
      p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
    f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 19");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 19");
    }
  //@siclog "Step 19A" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 20" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#6 (AMD PDU#6 carries SDU#7) containing the
  // last 50 bytes of SDU#7 in its data field, with the P-bit set. This AMD PDU segment is sent with SN 5.
  // SO=50 and LSF=1. No header extension part is provided.
  p_RLC_Rec.AM_VTS := 5;
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 100);  // @sic R5s110019, R5s110474 sic@
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU7], 50, 50);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset), // @sic R5s110201 sic@
                      tsc_P_Poll,
                      tsc_FI_EndOfSDU,
                      tsc_LSF_Last,
                      50,
                      v_RLC_Data1);
  //@siclog "Step 20A" siclog@
  // 100 ms after step 20 the SS assigns one default grant (UL grant allocation type 3).
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, 100 );
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 9, 25);

  //@siclog "Step 21" siclog@
  // Check: Does the UE transmit a STATUS PDU with ACK_SN=6, thus acknowledging the reception of PDUs
  // with SN=0 to SN=5, and NACK_SN=4, E1/E2 field for receipt of PDU#5 and NACK_SN=5,SOStart=0/SOEnd=49 for
  // segment 1 of PDU#6?
  p_RLC_Rec.AM_VTA := 6;
  v_NACK_List := cr_NACK_List_2NACKs (4,
                                      tsc_E2_SO_Follows,
                                      cr_Status_SO(int2bit(0, tsc_AM_SO_Size), tsc_SO_Special),
                                      5,
                                      tsc_E2_SO_Follows,
                                      cr_Status_SO(int2bit(0, tsc_AM_SO_Size), int2bit(49, tsc_AM_SO_Size)));
  v_NACK_List1 := cr_NACK_List_2NACKs(4,
                                      tsc_E2_NoSO_Follows,
                                      omit,
                                      5,
                                      tsc_E2_SO_Follows,
                                      cr_Status_SO(int2bit(0, tsc_AM_SO_Size), int2bit(49, tsc_AM_SO_Size)));
  alt {
    [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                           cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                               v_NACK_List,
                                                               v_Padding_5bits_Any) ) ) -> value v_ReceivedAsp
      {
        f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 21");
      }
    [] DRB.receive (car_DRB1_RLCStatusInd( eutra_Cell1,
                                           cr_STATUS_PDU_Nack( p_RLC_Rec.AM_VTA,
                                                               v_NACK_List1,
                                                               v_Padding_3bits_Any) ) ) -> value v_ReceivedAsp
      {
        f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 21");
      }
  } // alt
  p_RLC_Rec.AM_VTA := (p_RLC_Rec.AM_VTA + 1) mod 1024;
  
  //@siclog "Step 22" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#6 (AMD PDU#6 carries SDU#7) containing the
  // first 50 bytes of SDU#7 in its data field. SO=0 and LSF=0. No header extension part is provided.
  p_RLC_Rec.AM_VTS := 5;
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 100);  // @sic R5s110019, R5s110474 sic@
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU7], 0, 50);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                      tsc_P_NoPoll,
                      tsc_FI_StartOfSDU,
                      tsc_LSF_NotLast,
                      0,
                      v_RLC_Data1);
  
  //@siclog "Step 23" siclog@
  // The SS transmits one AMD PDU containing SDU#6 (100 bytes) in its data field, with the P-bit set.
  p_RLC_Rec.AM_VTS := 4;
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  f_TxAMD_SDU (p_RLC_Rec,
               cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
               tsc_P_Poll,
               tsc_RLC_SDU6);
  //@siclog "Step 23A" siclog@
  // SS waits for 60 ms to ensure UE RLC has all the required SDUs available in UL for loopback and then assigns one default grant (UL grant allocation type 3).
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 9, 25);
  //@siclog "Step 24" siclog@
  // The UE transmits a STATUS PDU with ACK_SN=6, thus acknowledging the reception of PDUs with SN=0 to SN=5
  p_RLC_Rec.AM_VTA := 6;
  // receive STATUS PDU + DATA PDU in the same TTI, thus in a list
  DRB.receive (car_DRB1_RLCAmStatusAndDataInd( eutra_Cell1,
                                               ?,
                                               ?)) -> value v_ReceivedAsp;
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].Status,
             cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA )))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 24");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 24");
    }
  //@siclog "Step 25" siclog@
  // The UE transmits RLC SDU#6.
  v_RLC_Data1 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU6];
  //@siclog "Step 26" siclog@
  // Check: Does the UE transmit RLC SDU#7?
  v_RLC_Data2 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU7];
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[1].AMD,
             cr_AMD_PDU_LIs (p_RLC_Rec.AM_VRR,
                             tsc_P_Poll,
                             tsc_FI_FullSDU,
                             cr_FlexPart_1LI (100),
                             {v_RLC_Data1, v_RLC_Data2})))
    {
      p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 26");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 26");
    }
  //@siclog "Step 26A" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  //@siclog "Step 27" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#7 (AMD PDU#7 carries SDU#8, SDU#9 and SDU#10) containing the
  // last 20 bytes of SDU#9 and the complete SDU#10 (100 bytes) in its data field, with the P-bit set. FI=10, SO=180 and LSF=1.
  // Header extension part present: E in fixed part header=1, E in extension part header=0, LI=20.
  p_RLC_Rec.AM_VTS := 6;
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(v_ReceivedAsp.Common.TimingInfo.SubFrame, 100);  // @sic R5s110019, R5s110474 sic@
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_AMD_SDUs8To10 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU8]
                     & p_RLC_Rec.RLC_DataList[tsc_RLC_SDU9]
                     & p_RLC_Rec.RLC_DataList[tsc_RLC_SDU10];
  v_RLC_Data1 := substr (v_AMD_SDUs8To10, 180, 20);
  v_RLC_Data2 := substr (v_AMD_SDUs8To10, 200, 100);
  f_TxAMD_SegList (p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                   tsc_P_Poll,
                   tsc_FI_EndOfSDU,
                   tsc_LSF_Last,
                   180,
                   {v_RLC_Data1, v_RLC_Data2});
  //@siclog "Step 27A" siclog@
  // 100 ms after step 27 the SS assigns one default grant (UL grant allocation type 3).
  v_Timing := f_EUTRA_TimingInfoAdd( v_Timing, 100 );
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 9, 25);

  //@siclog "Step 28" siclog@
  // The UE transmits a STATUS PDU NACK_SN field for receipt of PDU#7.
  p_RLC_Rec.AM_VTA := 7;
  v_NACK_List := cr_NACK_List (6,
                               tsc_E2_SO_Follows,
                               cr_Status_SO(int2bit(0, tsc_AM_SO_Size), int2bit(179, tsc_AM_SO_Size)));
  f_RxSTATUS_PDU_NACK(p_RLC_Rec, v_NACK_List, v_Padding_7bits_Any);
  
  //@siclog "Step 29" siclog@
  // The SS transmits an AMD PDU segment of AMD PDU#7 (AMD PDU#7 carries SDU#8, SDU#9 and SDU#10) containing the
  // last 20 bytes of SDU#8 and the complete SDU#9 in its data field, with the P-bit set. FI=10, SO=80 and LSF=0.
  // Header extension part present: E in fixed part header=1, E in extension part header=0, LI=20.
  p_RLC_Rec.AM_VTS := 6;
  v_Timing := f_EUTRA_TimingInfoAdjustAndAdd(p_RLC_Rec.TimeStampLastReceivedPDU, 100);  // @sic R5s110019, R5s110474 sic@
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_RLC_Data1 := substr (v_AMD_SDUs8To10, 80, 20);
  v_RLC_Data2 := substr (v_AMD_SDUs8To10, 100, 100);
  f_TxAMD_SegList (p_RLC_Rec,
                   cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                   tsc_P_Poll,
                   tsc_FI_EndOfSDU,
                   tsc_LSF_NotLast,
                   80,
                   {v_RLC_Data1, v_RLC_Data2});

  //@siclog "Step 29A" siclog@
  // 30 ms after step 29 the SS assigns one default grant (UL grant allocation type 3).
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 30); // @sic R5-106564 sic@
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 9, 25);

  //@siclog "Step 31" siclog@
  // 60 ms after step 29 the SS transmits an AMD PDU segment of AMD PDU#7 (AMD PDU#7 carries SDU#8, SDU#9 and SDU#10) containing the
  // first 80 bytes of SDU#8 in its data field, with the P-bit set. SO=0 and LSF=0. No header extension part is provided.
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 30);  // @sic R5s100538 sic@@sic R5s110008 sic@
  p_RLC_Rec.AM_VTS := 6;
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 0);
  v_RLC_Data1 := substr (v_AMD_SDUs8To10, 0, 80);
  f_TxAMD_PDU_OneSeg (p_RLC_Rec,
                      cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),  // @sic R5s110201 sic@
                      tsc_P_Poll,
                      tsc_FI_StartOfSDU,
                      tsc_LSF_NotLast,
                      0,
                      v_RLC_Data1);
  //@siclog "Step 31A" siclog@
  // The SS waits for 60 ms to ensure UE RLC has all the required SDUs available and then assigns one default UL grant (UL grant allocation type 3).
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 9, 25);

  //@siclog "Step 30" siclog@
  // The UE transmits a STATUS PDU NACK_SN field for receipt of PDU#7.
  p_RLC_Rec.AM_VTA := 7;
  v_NACK_List := cr_NACK_List (6,
                               tsc_E2_SO_Follows,
                               cr_Status_SO(int2bit(0, tsc_AM_SO_Size), int2bit(79, tsc_AM_SO_Size)));
  f_RxSTATUS_PDU_NACK (p_RLC_Rec, v_NACK_List, v_Padding_7bits_Any);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 30");
  
  //@siclog "Step 32" siclog@
  // Check: Does the UE transmit a STATUS PDU with  ACK_SN=7, thus acknowledging the reception of PDUs with SN=0 to SN=6,
  // and no NACK_SN provided ?
  p_RLC_Rec.AM_VTA := 7;
  // receive STATUS PDU + DATA PDU in the same TTI, thus in a list
  DRB.receive (car_DRB1_RLCAmStatusAndDataInd( eutra_Cell1,
                                               ?,
                                               ?)) -> value v_ReceivedAsp;
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[0].Status,
             cr_RLC_AM_StatusPDU_ACK_SN( p_RLC_Rec.AM_VTA )))
    {
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 32");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 32");
    }
  //@siclog "Step 33 void" siclog@
  //@siclog "Step 34 void" siclog@
  //@siclog "Step 35" siclog@
  // Check: Does the UE transmit RLC SDU#8, RLC SDU#9 and RLC SDU#10?
  v_RLC_Data1 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU8];
  v_RLC_Data2 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU9];
  v_RLC_Data3 := p_RLC_Rec.RLC_DataList[tsc_RLC_SDU10];
  if (match (v_ReceivedAsp.U_Plane.SubframeData.PduSduList.RlcPdu[1].AMD,
             cr_AMD_PDU_LIs (p_RLC_Rec.AM_VRR,
                             tsc_P_Poll,
                             tsc_FI_FullSDU,
                             cr_FlexPart_2LIs (100, 100),
                             {v_RLC_Data1, v_RLC_Data2, v_RLC_Data3})))
    {
      p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
      f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 35");
    }
  else
    {
      f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 35");
    }
  //@siclog "Step 36" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_18_TestBody

function f_TC_7_2_3_20_EUTRA()
  runs on EUTRA_PTC
{
  var RLC_SS_State v_RLC_Rec;
  
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  f_EUTRA_RbEst_Def_DisableBSR_PHR(eutra_Cell1);
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  fl_EUTRA_7_2_3_20_TestBody (v_RLC_Rec);
  f_EUTRA_TestBody_Set(false);
  
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_20_EUTRA

function fl_EUTRA_7_2_3_20_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{
  var integer i;
  var RLC_DataField_Type v_RLC_Data1;
  var integer v_PDCP_SDU_size := 38;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  
  timer t_WatchDog := 5.0;
  
  // PDCP SDUs of this size will be built, appended to a PDCP header,
  // and then used as RLC SDUs
  
  // generate 3 RLC SDUs = PDCP PDUs
  for (i := 0; i < 3; i:= i + 1) {
    p_RLC_Rec.TxDataSize := v_PDCP_SDU_size;
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12 ), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  
  //@siclog "Step 1" siclog@
  // SS creates 3 RLC SDUs of size 40 bytes segmented into two AMD PDUs each.
  // SS transmits AMD PDU#1 with SN=0, AMD PDU#2 with SN=1 and AMD PDU#3 twice with SN=2.
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_NoPoll,
                  tsc_FI_StartOfSDU,
                  v_RLC_Data1);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 20, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_NoPoll,
                  tsc_FI_EndOfSDU,
                  v_RLC_Data1);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 0, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_NoPoll,
                  tsc_FI_StartOfSDU,
                  v_RLC_Data1);
  // Retransmit AMD PDU#3
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   cs_TimingInfo_Now,
                                   p_RLC_Rec.AMD_PDU));
  
  //@siclog "Step 2" siclog@
  // Check: Does UE transmit RLC SDU#1?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU1);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 2");
  //@siclog "Step 2A" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 3" siclog@
  // SS transmits AMD PDU#4 with SN=3.
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 20, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_NoPoll,
                  tsc_FI_EndOfSDU,
                  v_RLC_Data1);

  //@siclog "Step 4" siclog@
  // Check: Does UE transmit RLC SDU#2?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU2);
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 4");
  //@siclog "Step 4A" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 5" siclog@
  // SS transmits AMD PDU#6 twice with SN=5.
  p_RLC_Rec.AM_VTS := 5;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 20, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_NoPoll,
                  tsc_FI_EndOfSDU,
                  v_RLC_Data1);
  // Retransmit AMD PDU#6
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   cs_TimingInfo_Now,
                                   p_RLC_Rec.AMD_PDU));
  
  //@siclog "Step 6" siclog@
  // SS transmits AMD PDU#5 twice with SN=4.
  p_RLC_Rec.AM_VTS := 4;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_NoPoll,
                  tsc_FI_StartOfSDU,
                  v_RLC_Data1);
  // Retransmit AMD PDU#5
  DRB.send (cas_DRB1_RLCAmDataReq (eutra_Cell1,
                                   cs_TimingInfo_Now,
                                   p_RLC_Rec.AMD_PDU));
  
  //@siclog "Step 7" siclog@
  // Check: Does UE transmit RLC SDU#3 once?
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU3);
  //@siclog "Step 7A" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  // Start timer t_WatchDog and check if UE sent another RLC SDU#3
  t_WatchDog.start;
  alt {
    [] t_WatchDog.timeout
      {
        f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 7");
      }
    [] DRB.receive (car_DRB1_RLCAmDataInd(eutra_Cell1, ?)) // catches more than SDU3
      {
        f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 7: UE transmits another RLC SDU");
      }
  } // alt
  
} // fl_EUTRA_7_2_3_20_TestBody

function f_TC_7_2_3_21_EUTRA() runs on EUTRA_PTC
{ // @sic R5s100256 sic@ @sic RP-101255 sic@ @sic R5s110168 change 4.4 sic@
  var RLC_SS_State v_RLC_Rec;
  var template (value) DRB_ToAddModList v_DRB_ToAddModList := {cs_DRB_ToAddMod_RLC_AM (tsc_DRB1,
                                                                                       cds_TX_AM_RLC_t_PollRetransmit (ms150),
                                                                                       cds_RX_AM_RLC_t_Reord (ms150))};
    
  //EUTRA initialisation
  f_EUTRA_Init(c1);
  //RLC global initialisation
  f_InitRLC_Record(v_RLC_Rec, AM_Mode);

  //RLC test case specific initialisation
  v_RLC_Rec.UL_PDCP_SDU_size := 38;
  
  // Cell configuration, with one AM DRB at the SS side
  f_EUTRA_CellConfig_Def (eutra_Cell1);
  // Preamble to enter UE in E-UTRA RRC_IDLE (state 2)
  f_EUTRA_Preamble (eutra_Cell1, STATE2A_TESTLOOP_ModeA);
  //set null AS ciphering algorithm
  f_EUTRA_AS_CipheringAlgorithm_Set(eea0);
  //entering UE test state 3, default values with BSR and PHR disabled
  //except t-Reordering = 150 ms and t-PollRetransmit = 150 ms
  //with PDCP Status Report Required configured to 'false'
  v_DRB_ToAddModList[0].pdcp_Config.rlc_AM.statusReportRequired := false;
  fl_EUTRA_GenericRbEst_WithRLC_AM_Params (eutra_Cell1, v_DRB_ToAddModList ); // @sic R5s110030 sic@
  // reconfigure DRB locally to set the required test mode AM mapped to TM
  f_EUTRA_SS_DRB1_ConfigAM_TM_Mode(eutra_Cell1);
  //closing the test loop (mode A), entering state 4
  f_EUTRA_CloseUE_TestLoopModeA(eutra_Cell1, cs_UE_TestLoopModeA_LB_Setup_NoScaling);
  
  f_EUTRA_TestBody_Set(true, layer2);  // @sic R5-100050 sic@
  fl_EUTRA_7_2_3_21_TestBody (v_RLC_Rec);
  f_EUTRA_TestBody_Set(false);
  
  // leaving UE test state 4
  //@sic R5-103847 Deactivate test loop and open test loop is removed sic@
  // postamble
  f_EUTRA_Postamble (eutra_Cell1, E3_TESTMODE);
} // f_TC_7_2_3_21_EUTRA

function fl_EUTRA_7_2_3_21_TestBody(inout RLC_SS_State p_RLC_Rec)
  runs on EUTRA_PTC
{ //@sic R5-104723 sic@ @sic RP-101255 sic@ @sic R5s110019/R5s110030 sic@
  var integer i;
  var RLC_DataField_Type v_RLC_Data1;
  var integer v_PDCP_SDU_size := 38;
  var template (value) PDCP_DataPdu_LongSN_Type v_PDCP_DataPDU;
  var RLC_DataField_Type v_SDU3_Received;
  var RLC_DataField_Type v_RLC_Data;
  var SubFrameTiming_Type v_Timing;
  var integer v_SubframeOffset;
  var EUTRA_FDD_TDD_Mode_Type  v_EUTRA_FDD_TDD_Mode;
  var SecurityActTimeList_Type v_SecurityActTimeList;
  var template (value) RadioBearer_Type v_DRB_Config;
  
  timer t_WatchDog := 5.0;
  
  // determine RAT to make the timing correct later on
  v_EUTRA_FDD_TDD_Mode := f_EUTRA_CellInfo_GetFDD_TDD (eutra_Cell1);

  // PDCP SDUs of this size will be built, appended to a PDCP header,
  // and then used as RLC SDUs
  
  // generate 3 RLC SDUs = PDCP PDUs
  for (i := 0; i < 3; i:= i + 1) {
    p_RLC_Rec.TxDataSize := v_PDCP_SDU_size;
    f_GetTxAM_PRBS (p_RLC_Rec);  // sets p_RLC_Rec.RLC_Data
    v_PDCP_DataPDU := cs_PDCP_DataPdu_LongSN(int2bit(i, tsc_PDCP_SN_Size_12), p_RLC_Rec.RLC_Data);
    p_RLC_Rec.RLC_DataList[i] := f_PDCP_PDU_Encvalue (cs_PDCP_PDU_LongSN(v_PDCP_DataPDU));
    p_RLC_Rec.Next_PDCP_TX_SN := (p_RLC_Rec.Next_PDCP_TX_SN + 1) mod (tsc_Maximum_PDCP_SN_12 + 1);
  }
  v_RLC_Data := substr(p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3],2,(v_PDCP_SDU_size));
  v_SDU3_Received := f_PDCP_PDU_Encvalue (cs_PDCP_DataLongSN(1,v_RLC_Data));
  
  //@siclog "Step 0" siclog@
  // The SS ignores scheduling requests and does not allocate any uplink grant based on that.
  f_EUTRA_StopULGrantTransmission_PUCCH_Sync ( eutra_Cell1, cs_TimingInfo_Now );

  //@siclog "Step 1" siclog@
  // SS creates 3 RLC SDUs of size 40 bytes segmented into two AMD PDUs each.
  // SS transmits AMD PDU#1 (SN=0), AMD PDU#2 (SN=1) and AMD PDU#4 (SN=3).
  v_Timing := f_EUTRA_GetNextSendOccasion(eutra_Cell1, tsc_EUTRA_DelayBeforeIntraCellHO); // @sic R5s110030 sic@
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 0, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                  tsc_P_NoPoll,
                  tsc_FI_StartOfSDU,
                  v_RLC_Data1);
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 1);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU1], 20, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                  tsc_P_NoPoll,
                  tsc_FI_EndOfSDU,
                  v_RLC_Data1);
  p_RLC_Rec.AM_VTS := 3;
  v_SubframeOffset := f_EUTRA_TimingInfoSubframeOffset(v_EUTRA_FDD_TDD_Mode, 2);
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU2], 20, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo(v_Timing.SFN.Number, v_SubframeOffset),
                  tsc_P_NoPoll,
                  tsc_FI_EndOfSDU,
                  v_RLC_Data1);
  //@siclog "Step 1A" siclog@
  // 60 ms after step 1 the SS allocates 1 UL grant of default size
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 60);
  f_EUTRA_OneULGrantTransmission(eutra_Cell1,
                                 cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                 9, 25);

  //@siclog "Step 4" siclog@
  // 90 ms after step 1 SS performs a RRC Connection Reconfiguration procedure including the
  // mobilityControlInfo IE triggering RLC-reestablishment.
  v_DRB_Config := cs_DRB1_ConfigAM_TM_Mode;
  v_DRB_Config.Config.AddOrReconfigure.LogicalChannelId := tsc_DRB1 + 2;
  v_Timing := f_EUTRA_TimingInfoAdd(v_Timing, 30); // i.e. 30 ms after step 1A
  v_SecurityActTimeList := f_EUTRA_RRC_CipherActTime_GetForHO (eutra_Cell1, tsc_DrbList_Def);  /* NOTE: since data transmission and HO are scheduled but PDCP COUNT is queried now
                                                                                                *       the queried PDCP COUNT will not be up to data i.e. ciphering will use wrong PDCP COUNT;
                                                                                                *       but this does not matter as long as NULL ciphering algorithm is used; FFS */
  f_EUTRA_508RRC_IntraLTE_HO_IntraCell_Step1_5 (eutra_Cell1,  // @sic R5s100430 change 2; R5s100524 sic@ @sic R5s110019/R5s110030 sic@
                                                cs_TimingInfo(v_Timing.SFN.Number, v_Timing.Subframe.Number),
                                                {v_DRB_Config},
                                                -,
                                                -,
                                                -,
                                                v_SecurityActTimeList);

  //@siclog "Step 2" siclog@
  // The UE returns RLC SDU#1.
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU1);

  f_EUTRA_508RRC_IntraLTE_HO_IntraCell_Step6_7(eutra_Cell1);  // @sic R5s110019/R5s110030 sic@

  //@siclog "Step 3" siclog@
  // SS does not acknowledge the reception of RLC SDU#1.
  p_RLC_Rec.AM_VRR := 0;

  //@siclog "Step 4AA" siclog@
  // The SS starts the UL default grant transmissions.
  f_EUTRA_StartDefULGrantTransmission(eutra_Cell1);

  //@siclog "Step 4A" siclog@
  // The UE retransmits RLC SDU #1.
  f_RxAMD_SDU(p_RLC_Rec, tsc_P_Poll, tsc_RLC_SDU1);
  //@siclog "Step 4B" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
  //@siclog "Step 5" siclog@
  // SS transmits AMD PDU#5 with SN=0 and the P field set to "1"
  p_RLC_Rec.AM_VTS := 0;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 0, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_Poll,
                  tsc_FI_StartOfSDU,
                  v_RLC_Data1);

  //@siclog "Step 6" siclog@
  // Check: Does the UE transmit a RLC STATUS PDU?
  p_RLC_Rec.AM_VTA := 1;
  f_RxSTATUS_PDU_ACK(p_RLC_Rec);
  
  //@siclog "Step 7" siclog@
  // SS transmits AMD PDU#6 with SN=Receiving_AM_Window_Size+2
  p_RLC_Rec.AM_VTS := tsc_AM_Window_Size + 2;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 20, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_NoPoll,
                  tsc_FI_EndOfSDU,
                  v_RLC_Data1);
  
  //@siclog "Step 8" siclog@
  // Check: Does UE return RLC SDU#3 within 1s?
  p_RLC_Rec.AM_VRR := 0;
  t_WatchDog.start(1.0);
  alt {
    [] DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                           cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR, tsc_P_NoPoll, {p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3]} )))
      {
        f_EUTRA_SetVerdictFailOrInconc(__FILE__, __LINE__, "Step 8");
      }
    [] t_WatchDog.timeout
      {
        // UE does not return RLC SDU#3 within 1s
      }
  }; // alt
  
  //@siclog "Step 9" siclog@
  // SS transmits AMD PDU#6 with SN=1
  p_RLC_Rec.AM_VTS := 1;
  v_RLC_Data1 := substr (p_RLC_Rec.RLC_DataList[tsc_RLC_SDU3], 20, 20);
  f_TxAMD_OnePDU (p_RLC_Rec,
                  cs_TimingInfo_Now,
                  tsc_P_NoPoll,
                  tsc_FI_EndOfSDU,
                  v_RLC_Data1);
  
  //@siclog "Step 10" siclog@
  // Check: Does UE return RLC SDU#3 with its first AMD PDU set to SN=1?
  p_RLC_Rec.AM_VRR := 1;
  DRB.receive (car_DRB1_RLCAmDataInd (eutra_Cell1,
                                      cr_AMD_PDUoneSDU(p_RLC_Rec.AM_VRR,
                                                       tsc_P_Poll,
                                                       {v_SDU3_Received})));
  p_RLC_Rec.AM_VRR := (p_RLC_Rec.AM_VRR + 1) mod 1024;
  f_EUTRA_PreliminaryPass(__FILE__, __LINE__, "Step 10");
  //@siclog "Step 10A" siclog@
  // Send STATUS PDU upon Pollbit.
  f_TxSTATUS_PDU(p_RLC_Rec);
  
} // fl_EUTRA_7_2_3_21_TestBody

} // end of group AM_Testcases

}
